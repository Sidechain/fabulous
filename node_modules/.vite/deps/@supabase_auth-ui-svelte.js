import {
  VIEWS,
  en_default,
  generateClassNames,
  merge,
  template
} from "./chunk-2QJPTLKX.js";
import {
  X,
  _,
  q
} from "./chunk-UEOUOKP5.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  compute_rest_props,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  onMount,
  prevent_default,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_input_value,
  space,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots
} from "./chunk-CKECMU6L.js";
import "./chunk-4EOJPDL2.js";

// node_modules/@supabase/auth-ui-svelte/dist/UI/Anchor.svelte
var file = "node_modules/@supabase/auth-ui-svelte/dist/UI/Anchor.svelte";
function create_fragment(ctx) {
  var _a, _b;
  let a;
  let a_style_value;
  let a_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3],
    {
      style: a_style_value = /*appearance*/
      (_b = (_a = ctx[1]) == null ? void 0 : _a.style) == null ? void 0 : _b.anchor
    },
    {
      class: a_class_value = /*classNames*/
      ctx[2].join(" ")
    }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, style: true, class: true });
      var a_nodes = children(a);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file, 19, 0, 566);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[6],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*appearance*/
        2 && a_style_value !== (a_style_value = /*appearance*/
        (_b2 = (_a2 = ctx2[1]) == null ? void 0 : _a2.style) == null ? void 0 : _b2.anchor)) && { style: a_style_value },
        (!current || dirty & /*classNames*/
        4 && a_class_value !== (a_class_value = /*classNames*/
        ctx2[2].join(" "))) && { class: a_class_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let classNames;
  const omit_props_names = ["href", "appearance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Anchor", slots, ["default"]);
  const anchorHTMLAttributes = _({
    fontFamily: "$bodyFontFamily",
    fontSize: "$baseBodySize",
    marginBottom: "$anchorBottomMargin",
    color: "$anchorTextColor",
    display: "block",
    textAlign: "center",
    textDecoration: "underline",
    "&:hover": { color: "$anchorTextHoverColor" }
  });
  let { href } = $$props;
  let { appearance = {} } = $$props;
  $$self.$$.on_mount.push(function() {
    if (href === void 0 && !("href" in $$props || $$self.$$.bound[$$self.$$.props["href"]])) {
      console.warn("<Anchor> was created without expected prop 'href'");
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("appearance" in $$new_props)
      $$invalidate(1, appearance = $$new_props.appearance);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    css: _,
    generateClassNames,
    anchorHTMLAttributes,
    href,
    appearance,
    classNames
  });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("appearance" in $$props)
      $$invalidate(1, appearance = $$new_props.appearance);
    if ("classNames" in $$props)
      $$invalidate(2, classNames = $$new_props.classNames);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*appearance*/
    2) {
      $:
        $$invalidate(2, classNames = generateClassNames("anchor", anchorHTMLAttributes(), appearance));
    }
  };
  return [href, appearance, classNames, $$restProps, $$scope, slots, click_handler];
}
var Anchor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { href: 0, appearance: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Anchor",
      options,
      id: create_fragment.name
    });
  }
  get href() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Anchor_default = Anchor;

// node_modules/@supabase/auth-ui-svelte/dist/UI/Button.svelte
var file2 = "node_modules/@supabase/auth-ui-svelte/dist/UI/Button.svelte";
function add_css(target) {
  append_styles(target, "svelte-ll2s9h", "button.svelte-ll2s9h{display:flex;align-items:center;justify-content:center;gap:8px;border-radius:var(--radii-borderRadiusButton);font-size:var(--fontSizes-baseButtonSize);padding:var(--space-buttonPadding);cursor:pointer;border-width:var(--borderWidths-buttonBorderWidth);border-style:solid;width:100%;transition-property:background-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:100ms}button.default.svelte-ll2s9h{background-color:var(--colors-defaultButtonBackground);color:var(--colors-defaultButtonText);border-color:var(--colors-defaultButtonBorder)}button.default.svelte-ll2s9h:hover{background-color:var(--colors-defaultButtonBackgroundHover)}button.primary.svelte-ll2s9h{background-color:var(--colors-brand);color:var(--colors-brandButtonText);border-color:var(--colors-brandAccent)}button.primary.svelte-ll2s9h:hover{background-color:var(--colors-brandAccent)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnV0dG9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFZQyxvQkFBTyxDQUNOLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsR0FBRyxDQUFFLEdBQUcsQ0FDUixhQUFhLENBQUUsSUFBSSwwQkFBMEIsQ0FBQyxDQUM5QyxTQUFTLENBQUUsSUFBSSwwQkFBMEIsQ0FBQyxDQUMxQyxPQUFPLENBQUUsSUFBSSxxQkFBcUIsQ0FBQyxDQUNuQyxNQUFNLENBQUUsT0FBTyxDQUNmLFlBQVksQ0FBRSxJQUFJLGdDQUFnQyxDQUFDLENBQ25ELFlBQVksQ0FBRSxLQUFLLENBQ25CLEtBQUssQ0FBRSxJQUFJLENBQ1gsbUJBQW1CLENBQUUsZ0JBQWdCLENBQ3JDLDBCQUEwQixDQUFFLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ3hELG1CQUFtQixDQUFFLEtBQ3RCLENBRUEsTUFBTSxzQkFBUyxDQUNkLGdCQUFnQixDQUFFLElBQUksZ0NBQWdDLENBQUMsQ0FDdkQsS0FBSyxDQUFFLElBQUksMEJBQTBCLENBQUMsQ0FDdEMsWUFBWSxDQUFFLElBQUksNEJBQTRCLENBQy9DLENBQ0EsTUFBTSxzQkFBUSxNQUFPLENBQ3BCLGdCQUFnQixDQUFFLElBQUkscUNBQXFDLENBQzVELENBRUEsTUFBTSxzQkFBUyxDQUNkLGdCQUFnQixDQUFFLElBQUksY0FBYyxDQUFDLENBQ3JDLEtBQUssQ0FBRSxJQUFJLHdCQUF3QixDQUFDLENBQ3BDLFlBQVksQ0FBRSxJQUFJLG9CQUFvQixDQUN2QyxDQUNBLE1BQU0sc0JBQVEsTUFBTyxDQUNwQixnQkFBZ0IsQ0FBRSxJQUFJLG9CQUFvQixDQUMzQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJCdXR0b24uc3ZlbHRlIl19 */");
}
function create_fragment2(ctx) {
  var _a, _b;
  let button;
  let button_style_value;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let button_levels = [
    /*$$restProps*/
    ctx[3],
    { disabled: (
      /*loading*/
      ctx[1]
    ) },
    {
      style: button_style_value = /*appearance*/
      (_b = (_a = ctx[0]) == null ? void 0 : _a.style) == null ? void 0 : _b.button
    },
    {
      class: button_class_value = /*classNames*/
      ctx[2].join(" ")
    }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { style: true, class: true });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(button, "svelte-ll2s9h", true);
      add_location(button, file2, 7, 0, 233);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*loading*/
        2) && { disabled: (
          /*loading*/
          ctx2[1]
        ) },
        (!current || dirty & /*appearance*/
        1 && button_style_value !== (button_style_value = /*appearance*/
        (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.style) == null ? void 0 : _b2.button)) && { style: button_style_value },
        (!current || dirty & /*classNames*/
        4 && button_class_value !== (button_class_value = /*classNames*/
        ctx2[2].join(" "))) && { class: button_class_value }
      ]));
      toggle_class(button, "svelte-ll2s9h", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let classNames;
  const omit_props_names = ["color", "appearance", "loading"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { color = "default" } = $$props;
  let { appearance = {} } = $$props;
  let { loading = false } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("appearance" in $$new_props)
      $$invalidate(0, appearance = $$new_props.appearance);
    if ("loading" in $$new_props)
      $$invalidate(1, loading = $$new_props.loading);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    generateClassNames,
    color,
    appearance,
    loading,
    classNames
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(4, color = $$new_props.color);
    if ("appearance" in $$props)
      $$invalidate(0, appearance = $$new_props.appearance);
    if ("loading" in $$props)
      $$invalidate(1, loading = $$new_props.loading);
    if ("classNames" in $$props)
      $$invalidate(2, classNames = $$new_props.classNames);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, appearance*/
    17) {
      $:
        $$invalidate(2, classNames = generateClassNames("button", color, appearance));
    }
  };
  return [
    appearance,
    loading,
    classNames,
    $$restProps,
    color,
    $$scope,
    slots,
    click_handler
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { color: 4, appearance: 0, loading: 1 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment2.name
    });
  }
  get color() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/@supabase/auth-ui-svelte/dist/UI/Container.svelte
var file3 = "node_modules/@supabase/auth-ui-svelte/dist/UI/Container.svelte";
function create_fragment3(ctx) {
  var _a, _b;
  let div;
  let div_style_value;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2],
    {
      style: div_style_value = /*appearance*/
      (_b = (_a = ctx[0]) == null ? void 0 : _a.style) == null ? void 0 : _b.container
    },
    {
      class: div_class_value = /*classNames*/
      ctx[1].join(" ")
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true, class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file3, 38, 0, 931);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*appearance*/
        1 && div_style_value !== (div_style_value = /*appearance*/
        (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.style) == null ? void 0 : _b2.container)) && { style: div_style_value },
        (!current || dirty & /*classNames*/
        2 && div_class_value !== (div_class_value = /*classNames*/
        ctx2[1].join(" "))) && { class: div_class_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let classNames;
  const omit_props_names = ["direction", "gap", "appearance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Container", slots, ["default"]);
  const containerDefaultStyles = _({
    display: "flex",
    gap: "4px",
    variants: {
      direction: {
        horizontal: {
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(48px, 1fr))"
        },
        vertical: { flexDirection: "column", margin: "8px 0" }
      },
      gap: {
        small: { gap: "4px" },
        medium: { gap: "8px" },
        large: { gap: "16px" }
      }
    }
  });
  let { direction = "horizontal" } = $$props;
  let { gap = "small" } = $$props;
  let { appearance = {} } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("direction" in $$new_props)
      $$invalidate(3, direction = $$new_props.direction);
    if ("gap" in $$new_props)
      $$invalidate(4, gap = $$new_props.gap);
    if ("appearance" in $$new_props)
      $$invalidate(0, appearance = $$new_props.appearance);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    css: _,
    generateClassNames,
    containerDefaultStyles,
    direction,
    gap,
    appearance,
    classNames
  });
  $$self.$inject_state = ($$new_props) => {
    if ("direction" in $$props)
      $$invalidate(3, direction = $$new_props.direction);
    if ("gap" in $$props)
      $$invalidate(4, gap = $$new_props.gap);
    if ("appearance" in $$props)
      $$invalidate(0, appearance = $$new_props.appearance);
    if ("classNames" in $$props)
      $$invalidate(1, classNames = $$new_props.classNames);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*direction, gap, appearance*/
    25) {
      $:
        $$invalidate(1, classNames = generateClassNames("container", containerDefaultStyles({ direction, gap }), appearance));
    }
  };
  return [appearance, classNames, $$restProps, direction, gap, $$scope, slots];
}
var Container = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { direction: 3, gap: 4, appearance: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Container",
      options,
      id: create_fragment3.name
    });
  }
  get direction() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Container_default = Container;

// node_modules/@supabase/auth-ui-svelte/dist/UI/Input.svelte
var file4 = "node_modules/@supabase/auth-ui-svelte/dist/UI/Input.svelte";
function create_fragment4(ctx) {
  var _a, _b;
  let input;
  let input_style_value;
  let input_class_value;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[3],
    {
      style: input_style_value = /*appearance*/
      (_b = (_a = ctx[1]) == null ? void 0 : _a.style) == null ? void 0 : _b.input
    },
    {
      class: input_class_value = /*classNames*/
      ctx[2].join(" ")
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { style: true, class: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file4, 48, 0, 1307);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = listen_dev(
          input,
          "input",
          /*input_input_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2;
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        dirty & /*appearance*/
        2 && input_style_value !== (input_style_value = /*appearance*/
        (_b2 = (_a2 = ctx2[1]) == null ? void 0 : _a2.style) == null ? void 0 : _b2.input) && { style: input_style_value },
        dirty & /*classNames*/
        4 && input_class_value !== (input_class_value = /*classNames*/
        ctx2[2].join(" ")) && { class: input_class_value }
      ]));
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let classNames;
  const omit_props_names = ["value", "appearance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input", slots, []);
  const inputDefaultStyles = _({
    fontFamily: "$inputFontFamily",
    background: "$inputBackground",
    borderRadius: "$inputBorderRadius",
    padding: "$inputPadding",
    cursor: "text",
    borderWidth: "$inputBorderWidth",
    borderColor: "$inputBorder",
    borderStyle: "solid",
    fontSize: "$baseInputSize",
    width: "100%",
    color: "$inputText",
    boxSizing: "border-box",
    "&:hover": {
      borderColor: "$inputBorderHover",
      outline: "none"
    },
    "&:focus": {
      borderColor: "$inputBorderFocus",
      outline: "none"
    },
    "&::placeholder": {
      color: "$inputPlaceholder",
      letterSpacing: "initial"
    },
    transitionPproperty: "background-color, border",
    transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
    transitionDuration: "100ms",
    variants: {
      type: {
        default: { letterSpacing: "0px" },
        password: { letterSpacing: "6px" }
      }
    }
  });
  let { value = void 0 } = $$props;
  let { appearance = {} } = $$props;
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("appearance" in $$new_props)
      $$invalidate(1, appearance = $$new_props.appearance);
  };
  $$self.$capture_state = () => ({
    css: _,
    generateClassNames,
    inputDefaultStyles,
    value,
    appearance,
    classNames
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("appearance" in $$props)
      $$invalidate(1, appearance = $$new_props.appearance);
    if ("classNames" in $$props)
      $$invalidate(2, classNames = $$new_props.classNames);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*appearance*/
    2) {
      $:
        $$invalidate(2, classNames = generateClassNames("input", inputDefaultStyles({ type: "default" }), appearance));
    }
  };
  return [value, appearance, classNames, $$restProps, input_input_handler];
}
var Input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { value: 0, appearance: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input",
      options,
      id: create_fragment4.name
    });
  }
  get value() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Input_default = Input;

// node_modules/@supabase/auth-ui-svelte/dist/UI/Label.svelte
var file5 = "node_modules/@supabase/auth-ui-svelte/dist/UI/Label.svelte";
function create_fragment5(ctx) {
  var _a, _b;
  let label;
  let label_style_value;
  let label_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let label_levels = [
    /*$$restProps*/
    ctx[2],
    {
      style: label_style_value = /*appearance*/
      (_b = (_a = ctx[0]) == null ? void 0 : _a.style) == null ? void 0 : _b.label
    },
    {
      class: label_class_value = /*classNames*/
      ctx[1].join(" ")
    }
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { style: true, class: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label, label_data);
      add_location(label, file5, 13, 0, 423);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*appearance*/
        1 && label_style_value !== (label_style_value = /*appearance*/
        (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.style) == null ? void 0 : _b2.label)) && { style: label_style_value },
        (!current || dirty & /*classNames*/
        2 && label_class_value !== (label_class_value = /*classNames*/
        ctx2[1].join(" "))) && { class: label_class_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let classNames;
  const omit_props_names = ["appearance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  const labelDefaultStyles = _({
    fontFamily: "$labelFontFamily",
    fontSize: "$baseLabelSize",
    marginBottom: "$labelBottomMargin",
    color: "$inputLabelText",
    display: "block"
  });
  let { appearance = {} } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("appearance" in $$new_props)
      $$invalidate(0, appearance = $$new_props.appearance);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    css: _,
    generateClassNames,
    labelDefaultStyles,
    appearance,
    classNames
  });
  $$self.$inject_state = ($$new_props) => {
    if ("appearance" in $$props)
      $$invalidate(0, appearance = $$new_props.appearance);
    if ("classNames" in $$props)
      $$invalidate(1, classNames = $$new_props.classNames);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*appearance*/
    1) {
      $:
        $$invalidate(1, classNames = generateClassNames("label", labelDefaultStyles(), appearance));
    }
  };
  return [appearance, classNames, $$restProps, $$scope, slots];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { appearance: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment5.name
    });
  }
  get appearance() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/@supabase/auth-ui-svelte/dist/UI/Message.svelte
var file6 = "node_modules/@supabase/auth-ui-svelte/dist/UI/Message.svelte";
function create_fragment6(ctx) {
  var _a, _b;
  let span;
  let span_style_value;
  let span_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let span_levels = [
    /*$$restProps*/
    ctx[2],
    {
      style: span_style_value = /*appearance*/
      (_b = (_a = ctx[0]) == null ? void 0 : _a.style) == null ? void 0 : _b.message
    },
    {
      class: span_class_value = /*classNames*/
      ctx[1].join(" ")
    }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { style: true, class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file6, 24, 0, 667);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*appearance*/
        1 && span_style_value !== (span_style_value = /*appearance*/
        (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.style) == null ? void 0 : _b2.message)) && { style: span_style_value },
        (!current || dirty & /*classNames*/
        2 && span_class_value !== (span_class_value = /*classNames*/
        ctx2[1].join(" "))) && { class: span_class_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let classNames;
  const omit_props_names = ["color", "appearance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Message", slots, ["default"]);
  const messageDefaultStyles = _({
    fontFamily: "$bodyFontFamily",
    fontSize: "$baseBodySize",
    marginBottom: "$labelBottomMargin",
    display: "block",
    textAlign: "center",
    variants: {
      color: {
        default: { color: "$messageText" },
        danger: { color: "$messageTextDanger" }
      }
    }
  });
  let { color = "default" } = $$props;
  let { appearance = {} } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(3, color = $$new_props.color);
    if ("appearance" in $$new_props)
      $$invalidate(0, appearance = $$new_props.appearance);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    css: _,
    generateClassNames,
    messageDefaultStyles,
    color,
    appearance,
    classNames
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(3, color = $$new_props.color);
    if ("appearance" in $$props)
      $$invalidate(0, appearance = $$new_props.appearance);
    if ("classNames" in $$props)
      $$invalidate(1, classNames = $$new_props.classNames);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, appearance*/
    9) {
      $:
        $$invalidate(1, classNames = generateClassNames("message", messageDefaultStyles({ color }), appearance));
    }
  };
  return [appearance, classNames, $$restProps, color, $$scope, slots];
}
var Message = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { color: 3, appearance: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Message",
      options,
      id: create_fragment6.name
    });
  }
  get color() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Message_default = Message;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/interfaces/EmailAuth.svelte
var file7 = "node_modules/@supabase/auth-ui-svelte/dist/Auth/interfaces/EmailAuth.svelte";
function add_css2(target) {
  append_styles(target, "svelte-nm5p4o", "form.svelte-nm5p4o{width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRW1haWxBdXRoLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEySkMsa0JBQUssQ0FDSixLQUFLLENBQUUsSUFDUiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJFbWFpbEF1dGguc3ZlbHRlIl19 */");
}
function create_default_slot_11(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[5]) == null ? void 0 : _a[
      /*lngKey*/
      ctx[10]
    ]) == null ? void 0 : _b.email_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      32 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[5]) == null ? void 0 : _a2[
        /*lngKey*/
        ctx2[10]
      ]) == null ? void 0 : _b2.email_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_11.name,
    type: "slot",
    source: '(63:4) <Label for=\\"email\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_10(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[5]) == null ? void 0 : _a[
      /*lngKey*/
      ctx[10]
    ]) == null ? void 0 : _b.password_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      32 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[5]) == null ? void 0 : _a2[
        /*lngKey*/
        ctx2[10]
      ]) == null ? void 0 : _b2.password_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10.name,
    type: "slot",
    source: '(76:4) <Label for=\\"password\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_9(ctx) {
  var _a, _b, _c, _d;
  let div0;
  let label0;
  let t0;
  let input0;
  let updating_value;
  let t1;
  let div1;
  let label1;
  let t2;
  let input1;
  let updating_value_1;
  let t3;
  let current;
  label0 = new Label_default({
    props: {
      for: "email",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function input0_value_binding(value) {
    ctx[16](value);
  }
  let input0_props = {
    id: "email",
    type: "email",
    name: "email",
    autofocus: true,
    placeholder: (
      /*i18n*/
      (_b = (_a = ctx[5]) == null ? void 0 : _a[
        /*lngKey*/
        ctx[10]
      ]) == null ? void 0 : _b.email_input_placeholder
    ),
    autocomplete: "email",
    appearance: (
      /*appearance*/
      ctx[6]
    )
  };
  if (
    /*email*/
    ctx[1] !== void 0
  ) {
    input0_props.value = /*email*/
    ctx[1];
  }
  input0 = new Input_default({ props: input0_props, $$inline: true });
  binding_callbacks.push(() => bind(input0, "value", input0_value_binding));
  label1 = new Label_default({
    props: {
      for: "password",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function input1_value_binding(value) {
    ctx[17](value);
  }
  let input1_props = {
    id: "password",
    type: "password",
    name: "password",
    placeholder: (
      /*i18n*/
      (_d = (_c = ctx[5]) == null ? void 0 : _c[
        /*lngKey*/
        ctx[10]
      ]) == null ? void 0 : _d.password_input_placeholder
    ),
    autocomplete: (
      /*authView*/
      ctx[0] === VIEWS.SIGN_IN ? "current-password" : "new-password"
    ),
    appearance: (
      /*appearance*/
      ctx[6]
    )
  };
  if (
    /*password*/
    ctx[2] !== void 0
  ) {
    input1_props.value = /*password*/
    ctx[2];
  }
  input1 = new Input_default({ props: input1_props, $$inline: true });
  binding_callbacks.push(() => bind(input1, "value", input1_value_binding));
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  const block = {
    c: function create() {
      div0 = element("div");
      create_component(label0.$$.fragment);
      t0 = space();
      create_component(input0.$$.fragment);
      t1 = space();
      div1 = element("div");
      create_component(label1.$$.fragment);
      t2 = space();
      create_component(input1.$$.fragment);
      t3 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", {});
      var div0_nodes = children(div0);
      claim_component(label0.$$.fragment, div0_nodes);
      t0 = claim_space(div0_nodes);
      claim_component(input0.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      claim_component(label1.$$.fragment, div1_nodes);
      t2 = claim_space(div1_nodes);
      claim_component(input1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      add_location(div0, file7, 61, 3, 2082);
      add_location(div1, file7, 74, 3, 2387);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      mount_component(label0, div0, null);
      append_hydration_dev(div0, t0);
      mount_component(input0, div0, null);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div1, anchor);
      mount_component(label1, div1, null);
      append_hydration_dev(div1, t2);
      mount_component(input1, div1, null);
      insert_hydration_dev(target, t3, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2, _c2, _d2;
      const label0_changes = {};
      if (dirty & /*appearance*/
      64)
        label0_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      4194336) {
        label0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      label0.$set(label0_changes);
      const input0_changes = {};
      if (dirty & /*i18n*/
      32)
        input0_changes.placeholder = /*i18n*/
        (_b2 = (_a2 = ctx2[5]) == null ? void 0 : _a2[
          /*lngKey*/
          ctx2[10]
        ]) == null ? void 0 : _b2.email_input_placeholder;
      if (dirty & /*appearance*/
      64)
        input0_changes.appearance = /*appearance*/
        ctx2[6];
      if (!updating_value && dirty & /*email*/
      2) {
        updating_value = true;
        input0_changes.value = /*email*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      input0.$set(input0_changes);
      const label1_changes = {};
      if (dirty & /*appearance*/
      64)
        label1_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      4194336) {
        label1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      label1.$set(label1_changes);
      const input1_changes = {};
      if (dirty & /*i18n*/
      32)
        input1_changes.placeholder = /*i18n*/
        (_d2 = (_c2 = ctx2[5]) == null ? void 0 : _c2[
          /*lngKey*/
          ctx2[10]
        ]) == null ? void 0 : _d2.password_input_placeholder;
      if (dirty & /*authView*/
      1)
        input1_changes.autocomplete = /*authView*/
        ctx2[0] === VIEWS.SIGN_IN ? "current-password" : "new-password";
      if (dirty & /*appearance*/
      64)
        input1_changes.appearance = /*appearance*/
        ctx2[6];
      if (!updating_value_1 && dirty & /*password*/
      4) {
        updating_value_1 = true;
        input1_changes.value = /*password*/
        ctx2[2];
        add_flush_callback(() => updating_value_1 = false);
      }
      input1.$set(input1_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label0.$$.fragment, local);
      transition_in(input0.$$.fragment, local);
      transition_in(label1.$$.fragment, local);
      transition_in(input1.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label0.$$.fragment, local);
      transition_out(input0.$$.fragment, local);
      transition_out(label1.$$.fragment, local);
      transition_out(input1.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div0);
      destroy_component(label0);
      destroy_component(input0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(div1);
      destroy_component(label1);
      destroy_component(input1);
      if (detaching)
        detach_dev(t3);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9.name,
    type: "slot",
    source: '(61:2) <Container direction=\\"vertical\\" gap=\\"large\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_8(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[5]) == null ? void 0 : _a[
      /*lngKey*/
      ctx[10]
    ]) == null ? void 0 : _b.button_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      32 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[5]) == null ? void 0 : _a2[
        /*lngKey*/
        ctx2[10]
      ]) == null ? void 0 : _b2.button_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8.name,
    type: "slot",
    source: '(89:2) <Button type=\\"submit\\" color=\\"primary\\" {loading} {appearance}    >',
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let container;
  let current;
  container = new Container_default({
    props: {
      direction: "vertical",
      gap: "small",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(container.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = {};
      if (dirty & /*appearance*/
      64)
        container_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, appearance, authView, i18n, magicLink*/
      4194417) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(93:2) {#if showLinks}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let anchor;
  let current;
  anchor = new Anchor_default({
    props: {
      href: "#auth-magic-link",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  anchor.$on(
    "click",
    /*click_handler*/
    ctx[18]
  );
  const block = {
    c: function create() {
      create_component(anchor.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchor.$$.fragment, nodes);
    },
    m: function mount(target, anchor$1) {
      mount_component(anchor, target, anchor$1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const anchor_changes = {};
      if (dirty & /*appearance*/
      64)
        anchor_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      4194336) {
        anchor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchor.$set(anchor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(95:4) {#if authView === VIEWS.SIGN_IN && magicLink}",
    ctx
  });
  return block;
}
function create_default_slot_7(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[5]) == null ? void 0 : _a.magic_link) == null ? void 0 : _b.link_text) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      32 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[5]) == null ? void 0 : _a2.magic_link) == null ? void 0 : _b2.link_text) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7.name,
    type: "slot",
    source: '(96:5) <Anchor       on:click={(e) => {        e.preventDefault();        authView = VIEWS.MAGIC_LINK;       }}       href=\\"#auth-magic-link\\"       {appearance}       >',
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let anchor;
  let current;
  anchor = new Anchor_default({
    props: {
      href: "#auth-sign-in",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  anchor.$on(
    "click",
    /*click_handler_3*/
    ctx[21]
  );
  const block = {
    c: function create() {
      create_component(anchor.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchor.$$.fragment, nodes);
    },
    m: function mount(target, anchor$1) {
      mount_component(anchor, target, anchor$1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const anchor_changes = {};
      if (dirty & /*appearance*/
      64)
        anchor_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      4194336) {
        anchor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchor.$set(anchor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(127:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let anchor0;
  let t;
  let anchor1;
  let current;
  anchor0 = new Anchor_default({
    props: {
      href: "#auth-forgot-password",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  anchor0.$on(
    "click",
    /*click_handler_1*/
    ctx[19]
  );
  anchor1 = new Anchor_default({
    props: {
      href: "#auth-sign-up",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  anchor1.$on(
    "click",
    /*click_handler_2*/
    ctx[20]
  );
  const block = {
    c: function create() {
      create_component(anchor0.$$.fragment);
      t = space();
      create_component(anchor1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchor0.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(anchor1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(anchor0, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(anchor1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const anchor0_changes = {};
      if (dirty & /*appearance*/
      64)
        anchor0_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      4194336) {
        anchor0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchor0.$set(anchor0_changes);
      const anchor1_changes = {};
      if (dirty & /*appearance*/
      64)
        anchor1_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      4194336) {
        anchor1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchor1.$set(anchor1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchor0.$$.fragment, local);
      transition_in(anchor1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchor0.$$.fragment, local);
      transition_out(anchor1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchor0, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(anchor1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(106:4) {#if authView === VIEWS.SIGN_IN}",
    ctx
  });
  return block;
}
function create_default_slot_6(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[5]) == null ? void 0 : _a.sign_in) == null ? void 0 : _b.link_text) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      32 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[5]) == null ? void 0 : _a2.sign_in) == null ? void 0 : _b2.link_text) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: '(128:5) <Anchor       on:click={(e) => {        e.preventDefault();        authView = VIEWS.SIGN_IN;       }}       href=\\"#auth-sign-in\\"       {appearance}      >',
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[5]) == null ? void 0 : _a.forgotten_password) == null ? void 0 : _b.link_text) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      32 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[5]) == null ? void 0 : _a2.forgotten_password) == null ? void 0 : _b2.link_text) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: '(107:5) <Anchor       on:click={(e) => {        e.preventDefault();        authView = VIEWS.FORGOTTEN_PASSWORD;       }}       href=\\"#auth-forgot-password\\"       {appearance}      >',
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[5]) == null ? void 0 : _a.sign_up) == null ? void 0 : _b.link_text) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      32 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[5]) == null ? void 0 : _a2.sign_up) == null ? void 0 : _b2.link_text) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: '(117:5) <Anchor       on:click={(e) => {        e.preventDefault();        authView = VIEWS.SIGN_UP;       }}       href=\\"#auth-sign-up\\"       {appearance}      >',
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let t;
  let current_block_type_index;
  let if_block1;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*authView*/
    ctx[0] === VIEWS.SIGN_IN && /*magicLink*/
    ctx[4] && create_if_block_4(ctx)
  );
  const if_block_creators = [create_if_block_3, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*authView*/
      ctx2[0] === VIEWS.SIGN_IN
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*authView*/
        ctx2[0] === VIEWS.SIGN_IN && /*magicLink*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*authView, magicLink*/
          17) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: '(94:3) <Container direction=\\"vertical\\" gap=\\"small\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let container;
  let t0;
  let button;
  let t1;
  let if_block_anchor;
  let current;
  container = new Container_default({
    props: {
      direction: "vertical",
      gap: "large",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button = new Button_default({
    props: {
      type: "submit",
      color: "primary",
      loading: (
        /*loading*/
        ctx[9]
      ),
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block = (
    /*showLinks*/
    ctx[3] && create_if_block_2(ctx)
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
      t0 = space();
      create_component(button.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(container.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(button.$$.fragment, nodes);
      t1 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(button, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = {};
      if (dirty & /*appearance*/
      64)
        container_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n, authView, appearance, password, email*/
      4194407) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
      const button_changes = {};
      if (dirty & /*loading*/
      512)
        button_changes.loading = /*loading*/
        ctx2[9];
      if (dirty & /*appearance*/
      64)
        button_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      4194336) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      if (
        /*showLinks*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*showLinks*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(button, detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: '(60:1) <Container direction=\\"vertical\\" gap=\\"large\\" {appearance}>',
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let message_1;
  let current;
  message_1 = new Message_default({
    props: {
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_1_changes = {};
      if (dirty & /*appearance*/
      64)
        message_1_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, message*/
      4194432) {
        message_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      message_1.$set(message_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(message_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(143:1) {#if message}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*message*/
        ctx[7]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*message*/
        ctx[7]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*message*/
      128)
        set_data_dev(
          t,
          /*message*/
          ctx2[7]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(144:2) <Message {appearance}>",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let message_1;
  let current;
  message_1 = new Message_default({
    props: {
      color: "danger",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_1_changes = {};
      if (dirty & /*appearance*/
      64)
        message_1_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, error*/
      4194560) {
        message_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      message_1.$set(message_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(message_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(148:1) {#if error}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*error*/
        ctx[8]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*error*/
        ctx[8]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*error*/
      256)
        set_data_dev(
          t,
          /*error*/
          ctx2[8]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(149:2) <Message color=\\"danger\\" {appearance}>',
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let form;
  let container;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  container = new Container_default({
    props: {
      direction: "vertical",
      gap: "large",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block0 = (
    /*message*/
    ctx[7] && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*error*/
    ctx[8] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      form = element("form");
      create_component(container.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { method: true, class: true });
      var form_nodes = children(form);
      claim_component(container.$$.fragment, form_nodes);
      t0 = claim_space(form_nodes);
      if (if_block0)
        if_block0.l(form_nodes);
      t1 = claim_space(form_nodes);
      if (if_block1)
        if_block1.l(form_nodes);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(form, "method", "post");
      attr_dev(form, "class", "svelte-nm5p4o");
      add_location(form, file7, 58, 0, 1899);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      mount_component(container, form, null);
      append_hydration_dev(form, t0);
      if (if_block0)
        if_block0.m(form, null);
      append_hydration_dev(form, t1);
      if (if_block1)
        if_block1.m(form, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(form, "submit", prevent_default(
          /*handleSubmit*/
          ctx[11]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const container_changes = {};
      if (dirty & /*appearance*/
      64)
        container_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, appearance, authView, i18n, magicLink, showLinks, loading, password, email*/
      4194943) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
      if (
        /*message*/
        ctx2[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*message*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(form, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*error*/
        ctx2[8]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*error*/
          256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(form, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      destroy_component(container);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EmailAuth", slots, ["default"]);
  let { authView = "sign_in" } = $$props;
  let { email = "" } = $$props;
  let { password = "" } = $$props;
  let { supabaseClient } = $$props;
  let { redirectTo = void 0 } = $$props;
  let { additionalData = void 0 } = $$props;
  let { showLinks = false } = $$props;
  let { magicLink = true } = $$props;
  let { i18n } = $$props;
  let { appearance } = $$props;
  let message = "";
  let error = "";
  let loading = false;
  let lngKey = authView === "sign_in" ? "sign_in" : "sign_up";
  async function handleSubmit() {
    var _a;
    $$invalidate(9, loading = true);
    $$invalidate(8, error = "");
    $$invalidate(7, message = "");
    switch (authView) {
      case VIEWS.SIGN_IN:
        const { error: signInError } = await supabaseClient.auth.signInWithPassword({ email, password });
        if (signInError)
          $$invalidate(8, error = signInError.message);
        $$invalidate(9, loading = false);
        break;
      case VIEWS.SIGN_UP:
        let options = { emailRedirectTo: redirectTo };
        if (additionalData) {
          options.data = additionalData;
        }
        const { data: { user: signUpUser, session: signUpSession }, error: signUpError } = await supabaseClient.auth.signUp({ email, password, options });
        if (signUpError)
          $$invalidate(8, error = signUpError.message);
        else if (signUpUser && !signUpSession)
          $$invalidate(7, message = (_a = i18n.sign_up) == null ? void 0 : _a.confirmation_text);
        break;
    }
    $$invalidate(9, loading = false);
  }
  $$self.$$.on_mount.push(function() {
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<EmailAuth> was created without expected prop 'supabaseClient'");
    }
    if (i18n === void 0 && !("i18n" in $$props || $$self.$$.bound[$$self.$$.props["i18n"]])) {
      console.warn("<EmailAuth> was created without expected prop 'i18n'");
    }
    if (appearance === void 0 && !("appearance" in $$props || $$self.$$.bound[$$self.$$.props["appearance"]])) {
      console.warn("<EmailAuth> was created without expected prop 'appearance'");
    }
  });
  const writable_props = [
    "authView",
    "email",
    "password",
    "supabaseClient",
    "redirectTo",
    "additionalData",
    "showLinks",
    "magicLink",
    "i18n",
    "appearance"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<EmailAuth> was created with unknown prop '${key}'`);
  });
  function input0_value_binding(value) {
    email = value;
    $$invalidate(1, email);
  }
  function input1_value_binding(value) {
    password = value;
    $$invalidate(2, password);
  }
  const click_handler = (e) => {
    e.preventDefault();
    $$invalidate(0, authView = VIEWS.MAGIC_LINK);
  };
  const click_handler_1 = (e) => {
    e.preventDefault();
    $$invalidate(0, authView = VIEWS.FORGOTTEN_PASSWORD);
  };
  const click_handler_2 = (e) => {
    e.preventDefault();
    $$invalidate(0, authView = VIEWS.SIGN_UP);
  };
  const click_handler_3 = (e) => {
    e.preventDefault();
    $$invalidate(0, authView = VIEWS.SIGN_IN);
  };
  $$self.$$set = ($$props2) => {
    if ("authView" in $$props2)
      $$invalidate(0, authView = $$props2.authView);
    if ("email" in $$props2)
      $$invalidate(1, email = $$props2.email);
    if ("password" in $$props2)
      $$invalidate(2, password = $$props2.password);
    if ("supabaseClient" in $$props2)
      $$invalidate(12, supabaseClient = $$props2.supabaseClient);
    if ("redirectTo" in $$props2)
      $$invalidate(13, redirectTo = $$props2.redirectTo);
    if ("additionalData" in $$props2)
      $$invalidate(14, additionalData = $$props2.additionalData);
    if ("showLinks" in $$props2)
      $$invalidate(3, showLinks = $$props2.showLinks);
    if ("magicLink" in $$props2)
      $$invalidate(4, magicLink = $$props2.magicLink);
    if ("i18n" in $$props2)
      $$invalidate(5, i18n = $$props2.i18n);
    if ("appearance" in $$props2)
      $$invalidate(6, appearance = $$props2.appearance);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Anchor: Anchor_default,
    Button: Button_default,
    Container: Container_default,
    Input: Input_default,
    Label: Label_default,
    Message: Message_default,
    VIEWS,
    authView,
    email,
    password,
    supabaseClient,
    redirectTo,
    additionalData,
    showLinks,
    magicLink,
    i18n,
    appearance,
    message,
    error,
    loading,
    lngKey,
    handleSubmit
  });
  $$self.$inject_state = ($$props2) => {
    if ("authView" in $$props2)
      $$invalidate(0, authView = $$props2.authView);
    if ("email" in $$props2)
      $$invalidate(1, email = $$props2.email);
    if ("password" in $$props2)
      $$invalidate(2, password = $$props2.password);
    if ("supabaseClient" in $$props2)
      $$invalidate(12, supabaseClient = $$props2.supabaseClient);
    if ("redirectTo" in $$props2)
      $$invalidate(13, redirectTo = $$props2.redirectTo);
    if ("additionalData" in $$props2)
      $$invalidate(14, additionalData = $$props2.additionalData);
    if ("showLinks" in $$props2)
      $$invalidate(3, showLinks = $$props2.showLinks);
    if ("magicLink" in $$props2)
      $$invalidate(4, magicLink = $$props2.magicLink);
    if ("i18n" in $$props2)
      $$invalidate(5, i18n = $$props2.i18n);
    if ("appearance" in $$props2)
      $$invalidate(6, appearance = $$props2.appearance);
    if ("message" in $$props2)
      $$invalidate(7, message = $$props2.message);
    if ("error" in $$props2)
      $$invalidate(8, error = $$props2.error);
    if ("loading" in $$props2)
      $$invalidate(9, loading = $$props2.loading);
    if ("lngKey" in $$props2)
      $$invalidate(10, lngKey = $$props2.lngKey);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    authView,
    email,
    password,
    showLinks,
    magicLink,
    i18n,
    appearance,
    message,
    error,
    loading,
    lngKey,
    handleSubmit,
    supabaseClient,
    redirectTo,
    additionalData,
    slots,
    input0_value_binding,
    input1_value_binding,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    $$scope
  ];
}
var EmailAuth = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        authView: 0,
        email: 1,
        password: 2,
        supabaseClient: 12,
        redirectTo: 13,
        additionalData: 14,
        showLinks: 3,
        magicLink: 4,
        i18n: 5,
        appearance: 6
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EmailAuth",
      options,
      id: create_fragment7.name
    });
  }
  get authView() {
    throw new Error("<EmailAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set authView(value) {
    throw new Error("<EmailAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get email() {
    throw new Error("<EmailAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set email(value) {
    throw new Error("<EmailAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get password() {
    throw new Error("<EmailAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set password(value) {
    throw new Error("<EmailAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get supabaseClient() {
    throw new Error("<EmailAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<EmailAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirectTo() {
    throw new Error("<EmailAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirectTo(value) {
    throw new Error("<EmailAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get additionalData() {
    throw new Error("<EmailAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set additionalData(value) {
    throw new Error("<EmailAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLinks() {
    throw new Error("<EmailAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLinks(value) {
    throw new Error("<EmailAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get magicLink() {
    throw new Error("<EmailAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set magicLink(value) {
    throw new Error("<EmailAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get i18n() {
    throw new Error("<EmailAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set i18n(value) {
    throw new Error("<EmailAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<EmailAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<EmailAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EmailAuth_default = EmailAuth;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/interfaces/ForgottenPassword.svelte
var file8 = "node_modules/@supabase/auth-ui-svelte/dist/Auth/interfaces/ForgottenPassword.svelte";
function add_css3(target) {
  append_styles(target, "svelte-nm5p4o", "form.svelte-nm5p4o{width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9yZ290dGVuUGFzc3dvcmQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTZFQyxrQkFBSyxDQUNKLEtBQUssQ0FBRSxJQUNSIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkZvcmdvdHRlblBhc3N3b3JkLnN2ZWx0ZSJdfQ== */");
}
function create_default_slot_62(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[2]) == null ? void 0 : _a.forgotten_password) == null ? void 0 : _b.email_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      4 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.forgotten_password) == null ? void 0 : _b2.email_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_62.name,
    type: "slot",
    source: '(37:4) <Label for=\\"email\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_52(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[2]) == null ? void 0 : _a.forgotten_password) == null ? void 0 : _b.button_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      4 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.forgotten_password) == null ? void 0 : _b2.button_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_52.name,
    type: "slot",
    source: '(49:3) <Button type=\\"submit\\" color=\\"primary\\" {loading} {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_42(ctx) {
  var _a, _b;
  let div;
  let label;
  let t0;
  let input;
  let updating_value;
  let t1;
  let button;
  let current;
  label = new Label_default({
    props: {
      for: "email",
      appearance: (
        /*appearance*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot_62] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function input_value_binding(value) {
    ctx[11](value);
  }
  let input_props = {
    id: "email",
    type: "email",
    name: "email",
    autofocus: true,
    placeholder: (
      /*i18n*/
      (_b = (_a = ctx[2]) == null ? void 0 : _a.forgotten_password) == null ? void 0 : _b.email_input_placeholder
    ),
    autocomplete: "email",
    appearance: (
      /*appearance*/
      ctx[4]
    )
  };
  if (
    /*email*/
    ctx[1] !== void 0
  ) {
    input_props.value = /*email*/
    ctx[1];
  }
  input = new Input_default({ props: input_props, $$inline: true });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  button = new Button_default({
    props: {
      type: "submit",
      color: "primary",
      loading: (
        /*loading*/
        ctx[7]
      ),
      appearance: (
        /*appearance*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot_52] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(label.$$.fragment);
      t0 = space();
      create_component(input.$$.fragment);
      t1 = space();
      create_component(button.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(label.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      claim_component(input.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      claim_component(button.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file8, 35, 3, 1161);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(label, div, null);
      append_hydration_dev(div, t0);
      mount_component(input, div, null);
      insert_hydration_dev(target, t1, anchor);
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      const label_changes = {};
      if (dirty & /*appearance*/
      16)
        label_changes.appearance = /*appearance*/
        ctx2[4];
      if (dirty & /*$$scope, i18n*/
      8196) {
        label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      label.$set(label_changes);
      const input_changes = {};
      if (dirty & /*i18n*/
      4)
        input_changes.placeholder = /*i18n*/
        (_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.forgotten_password) == null ? void 0 : _b2.email_input_placeholder;
      if (dirty & /*appearance*/
      16)
        input_changes.appearance = /*appearance*/
        ctx2[4];
      if (!updating_value && dirty & /*email*/
      2) {
        updating_value = true;
        input_changes.value = /*email*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
      const button_changes = {};
      if (dirty & /*loading*/
      128)
        button_changes.loading = /*loading*/
        ctx2[7];
      if (dirty & /*appearance*/
      16)
        button_changes.appearance = /*appearance*/
        ctx2[4];
      if (dirty & /*$$scope, i18n*/
      8196) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      transition_in(input.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label.$$.fragment, local);
      transition_out(input.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(label);
      destroy_component(input);
      if (detaching)
        detach_dev(t1);
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_42.name,
    type: "slot",
    source: '(35:2) <Container direction=\\"vertical\\" gap=\\"large\\" {appearance}>',
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let anchor;
  let current;
  anchor = new Anchor_default({
    props: {
      href: "#auth-magic-link",
      appearance: (
        /*appearance*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  anchor.$on(
    "click",
    /*click_handler*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(anchor.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchor.$$.fragment, nodes);
    },
    m: function mount(target, anchor$1) {
      mount_component(anchor, target, anchor$1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const anchor_changes = {};
      if (dirty & /*appearance*/
      16)
        anchor_changes.appearance = /*appearance*/
        ctx2[4];
      if (dirty & /*$$scope, i18n*/
      8196) {
        anchor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchor.$set(anchor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(54:2) {#if showLinks}",
    ctx
  });
  return block;
}
function create_default_slot_32(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[2]) == null ? void 0 : _a.sign_in) == null ? void 0 : _b.link_text) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      4 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.sign_in) == null ? void 0 : _b2.link_text) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: '(55:3) <Anchor     on:click={(e) => {      e.preventDefault();      authView = VIEWS.SIGN_IN;     }}     href=\\"#auth-magic-link\\"     {appearance}>',
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let message_1;
  let current;
  message_1 = new Message_default({
    props: {
      appearance: (
        /*appearance*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_1_changes = {};
      if (dirty & /*appearance*/
      16)
        message_1_changes.appearance = /*appearance*/
        ctx2[4];
      if (dirty & /*$$scope, message*/
      8224) {
        message_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      message_1.$set(message_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(message_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(64:2) {#if message}",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*message*/
        ctx[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*message*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*message*/
      32)
        set_data_dev(
          t,
          /*message*/
          ctx2[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: "(65:3) <Message {appearance}>",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let message_1;
  let current;
  message_1 = new Message_default({
    props: {
      color: "danger",
      appearance: (
        /*appearance*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_1_changes = {};
      if (dirty & /*appearance*/
      16)
        message_1_changes.appearance = /*appearance*/
        ctx2[4];
      if (dirty & /*$$scope, error*/
      8256) {
        message_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      message_1.$set(message_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(message_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(69:2) {#if error}",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*error*/
        ctx[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*error*/
        ctx[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*error*/
      64)
        set_data_dev(
          t,
          /*error*/
          ctx2[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: '(70:3) <Message color=\\"danger\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let container;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  container = new Container_default({
    props: {
      direction: "vertical",
      gap: "large",
      appearance: (
        /*appearance*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot_42] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block0 = (
    /*showLinks*/
    ctx[3] && create_if_block_22(ctx)
  );
  let if_block1 = (
    /*message*/
    ctx[5] && create_if_block_12(ctx)
  );
  let if_block2 = (
    /*error*/
    ctx[6] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(container.$$.fragment, nodes);
      t0 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = {};
      if (dirty & /*appearance*/
      16)
        container_changes.appearance = /*appearance*/
        ctx2[4];
      if (dirty & /*$$scope, loading, appearance, i18n, email*/
      8342) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
      if (
        /*showLinks*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*showLinks*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_22(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*message*/
        ctx2[5]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*message*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*error*/
        ctx2[6]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*error*/
          64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: '(34:1) <Container direction=\\"vertical\\" gap=\\"large\\" {appearance}>',
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let form;
  let container;
  let current;
  let mounted;
  let dispose;
  container = new Container_default({
    props: {
      direction: "vertical",
      gap: "large",
      appearance: (
        /*appearance*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      form = element("form");
      create_component(container.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { id: true, method: true, class: true });
      var form_nodes = children(form);
      claim_component(container.$$.fragment, form_nodes);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(form, "id", "auth-forgot-password");
      attr_dev(form, "method", "post");
      attr_dev(form, "class", "svelte-nm5p4o");
      add_location(form, file8, 32, 0, 952);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      mount_component(container, form, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(form, "submit", prevent_default(
          /*handleSubmit*/
          ctx[8]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const container_changes = {};
      if (dirty & /*appearance*/
      16)
        container_changes.appearance = /*appearance*/
        ctx2[4];
      if (dirty & /*$$scope, appearance, error, message, authView, i18n, showLinks, loading, email*/
      8447) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      destroy_component(container);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ForgottenPassword", slots, []);
  let { i18n } = $$props;
  let { supabaseClient } = $$props;
  let { authView } = $$props;
  let { redirectTo = void 0 } = $$props;
  let { email = "" } = $$props;
  let { showLinks = false } = $$props;
  let { appearance } = $$props;
  let message = "";
  let error = "";
  let loading = false;
  async function handleSubmit() {
    var _a;
    $$invalidate(7, loading = true);
    $$invalidate(6, error = "");
    $$invalidate(5, message = "");
    const { error: resetPasswordError } = await supabaseClient.auth.resetPasswordForEmail(email, { redirectTo });
    if (resetPasswordError)
      $$invalidate(6, error = resetPasswordError.message);
    else
      $$invalidate(5, message = (_a = i18n.forgotten_password) == null ? void 0 : _a.confirmation_text);
    $$invalidate(7, loading = false);
  }
  $$self.$$.on_mount.push(function() {
    if (i18n === void 0 && !("i18n" in $$props || $$self.$$.bound[$$self.$$.props["i18n"]])) {
      console.warn("<ForgottenPassword> was created without expected prop 'i18n'");
    }
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<ForgottenPassword> was created without expected prop 'supabaseClient'");
    }
    if (authView === void 0 && !("authView" in $$props || $$self.$$.bound[$$self.$$.props["authView"]])) {
      console.warn("<ForgottenPassword> was created without expected prop 'authView'");
    }
    if (appearance === void 0 && !("appearance" in $$props || $$self.$$.bound[$$self.$$.props["appearance"]])) {
      console.warn("<ForgottenPassword> was created without expected prop 'appearance'");
    }
  });
  const writable_props = [
    "i18n",
    "supabaseClient",
    "authView",
    "redirectTo",
    "email",
    "showLinks",
    "appearance"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ForgottenPassword> was created with unknown prop '${key}'`);
  });
  function input_value_binding(value) {
    email = value;
    $$invalidate(1, email);
  }
  const click_handler = (e) => {
    e.preventDefault();
    $$invalidate(0, authView = VIEWS.SIGN_IN);
  };
  $$self.$$set = ($$props2) => {
    if ("i18n" in $$props2)
      $$invalidate(2, i18n = $$props2.i18n);
    if ("supabaseClient" in $$props2)
      $$invalidate(9, supabaseClient = $$props2.supabaseClient);
    if ("authView" in $$props2)
      $$invalidate(0, authView = $$props2.authView);
    if ("redirectTo" in $$props2)
      $$invalidate(10, redirectTo = $$props2.redirectTo);
    if ("email" in $$props2)
      $$invalidate(1, email = $$props2.email);
    if ("showLinks" in $$props2)
      $$invalidate(3, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(4, appearance = $$props2.appearance);
  };
  $$self.$capture_state = () => ({
    Anchor: Anchor_default,
    Button: Button_default,
    Container: Container_default,
    Input: Input_default,
    Label: Label_default,
    Message: Message_default,
    VIEWS,
    i18n,
    supabaseClient,
    authView,
    redirectTo,
    email,
    showLinks,
    appearance,
    message,
    error,
    loading,
    handleSubmit
  });
  $$self.$inject_state = ($$props2) => {
    if ("i18n" in $$props2)
      $$invalidate(2, i18n = $$props2.i18n);
    if ("supabaseClient" in $$props2)
      $$invalidate(9, supabaseClient = $$props2.supabaseClient);
    if ("authView" in $$props2)
      $$invalidate(0, authView = $$props2.authView);
    if ("redirectTo" in $$props2)
      $$invalidate(10, redirectTo = $$props2.redirectTo);
    if ("email" in $$props2)
      $$invalidate(1, email = $$props2.email);
    if ("showLinks" in $$props2)
      $$invalidate(3, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(4, appearance = $$props2.appearance);
    if ("message" in $$props2)
      $$invalidate(5, message = $$props2.message);
    if ("error" in $$props2)
      $$invalidate(6, error = $$props2.error);
    if ("loading" in $$props2)
      $$invalidate(7, loading = $$props2.loading);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    authView,
    email,
    i18n,
    showLinks,
    appearance,
    message,
    error,
    loading,
    handleSubmit,
    supabaseClient,
    redirectTo,
    input_value_binding,
    click_handler
  ];
}
var ForgottenPassword = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        i18n: 2,
        supabaseClient: 9,
        authView: 0,
        redirectTo: 10,
        email: 1,
        showLinks: 3,
        appearance: 4
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ForgottenPassword",
      options,
      id: create_fragment8.name
    });
  }
  get i18n() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set i18n(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get supabaseClient() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get authView() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set authView(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirectTo() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirectTo(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get email() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set email(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLinks() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLinks(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ForgottenPassword_default = ForgottenPassword;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/interfaces/MagicLink.svelte
var file9 = "node_modules/@supabase/auth-ui-svelte/dist/Auth/interfaces/MagicLink.svelte";
function add_css4(target) {
  append_styles(target, "svelte-nm5p4o", "form.svelte-nm5p4o{width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFnaWNMaW5rLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnRkMsa0JBQUssQ0FDSixLQUFLLENBQUUsSUFDUiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNYWdpY0xpbmsuc3ZlbHRlIl19 */");
}
function create_default_slot_63(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[2]) == null ? void 0 : _a.magic_link) == null ? void 0 : _b.email_input_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      4 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.magic_link) == null ? void 0 : _b2.email_input_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_63.name,
    type: "slot",
    source: '(40:4) <Label for=\\"email\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_53(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[2]) == null ? void 0 : _a.magic_link) == null ? void 0 : _b.button_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      4 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.magic_link) == null ? void 0 : _b2.button_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_53.name,
    type: "slot",
    source: '(52:3) <Button type=\\"submit\\" color=\\"primary\\" {loading} {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_43(ctx) {
  var _a, _b;
  let div;
  let label;
  let t0;
  let input;
  let updating_value;
  let t1;
  let button;
  let current;
  label = new Label_default({
    props: {
      for: "email",
      appearance: (
        /*appearance*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_63] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function input_value_binding(value) {
    ctx[11](value);
  }
  let input_props = {
    id: "email",
    type: "email",
    name: "email",
    autofocus: true,
    placeholder: (
      /*i18n*/
      (_b = (_a = ctx[2]) == null ? void 0 : _a.magic_link) == null ? void 0 : _b.email_input_placeholder
    ),
    autocomplete: "email",
    appearance: (
      /*appearance*/
      ctx[3]
    )
  };
  if (
    /*email*/
    ctx[1] !== void 0
  ) {
    input_props.value = /*email*/
    ctx[1];
  }
  input = new Input_default({ props: input_props, $$inline: true });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  button = new Button_default({
    props: {
      type: "submit",
      color: "primary",
      loading: (
        /*loading*/
        ctx[7]
      ),
      appearance: (
        /*appearance*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_53] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(label.$$.fragment);
      t0 = space();
      create_component(input.$$.fragment);
      t1 = space();
      create_component(button.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(label.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      claim_component(input.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      claim_component(button.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file9, 38, 3, 1198);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(label, div, null);
      append_hydration_dev(div, t0);
      mount_component(input, div, null);
      insert_hydration_dev(target, t1, anchor);
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      const label_changes = {};
      if (dirty & /*appearance*/
      8)
        label_changes.appearance = /*appearance*/
        ctx2[3];
      if (dirty & /*$$scope, i18n*/
      8196) {
        label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      label.$set(label_changes);
      const input_changes = {};
      if (dirty & /*i18n*/
      4)
        input_changes.placeholder = /*i18n*/
        (_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.magic_link) == null ? void 0 : _b2.email_input_placeholder;
      if (dirty & /*appearance*/
      8)
        input_changes.appearance = /*appearance*/
        ctx2[3];
      if (!updating_value && dirty & /*email*/
      2) {
        updating_value = true;
        input_changes.value = /*email*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
      const button_changes = {};
      if (dirty & /*loading*/
      128)
        button_changes.loading = /*loading*/
        ctx2[7];
      if (dirty & /*appearance*/
      8)
        button_changes.appearance = /*appearance*/
        ctx2[3];
      if (dirty & /*$$scope, i18n*/
      8196) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      transition_in(input.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label.$$.fragment, local);
      transition_out(input.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(label);
      destroy_component(input);
      if (detaching)
        detach_dev(t1);
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_43.name,
    type: "slot",
    source: '(38:2) <Container direction=\\"vertical\\" gap=\\"large\\" {appearance}>',
    ctx
  });
  return block;
}
function create_if_block_23(ctx) {
  let anchor;
  let current;
  anchor = new Anchor_default({
    props: {
      href: "#auth-sign-in",
      appearance: (
        /*appearance*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_33] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  anchor.$on(
    "click",
    /*click_handler*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(anchor.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchor.$$.fragment, nodes);
    },
    m: function mount(target, anchor$1) {
      mount_component(anchor, target, anchor$1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const anchor_changes = {};
      if (dirty & /*appearance*/
      8)
        anchor_changes.appearance = /*appearance*/
        ctx2[3];
      if (dirty & /*$$scope, i18n*/
      8196) {
        anchor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchor.$set(anchor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(57:2) {#if showLinks}",
    ctx
  });
  return block;
}
function create_default_slot_33(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[2]) == null ? void 0 : _a.sign_in) == null ? void 0 : _b.link_text) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      4 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.sign_in) == null ? void 0 : _b2.link_text) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_33.name,
    type: "slot",
    source: '(58:3) <Anchor     on:click={(e) => {      e.preventDefault();      authView = VIEWS.SIGN_IN;     }}     href=\\"#auth-sign-in\\"     {appearance}>',
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let message_1;
  let current;
  message_1 = new Message_default({
    props: {
      appearance: (
        /*appearance*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_1_changes = {};
      if (dirty & /*appearance*/
      8)
        message_1_changes.appearance = /*appearance*/
        ctx2[3];
      if (dirty & /*$$scope, message*/
      8224) {
        message_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      message_1.$set(message_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(message_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(67:2) {#if message}",
    ctx
  });
  return block;
}
function create_default_slot_23(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*message*/
        ctx[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*message*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*message*/
      32)
        set_data_dev(
          t,
          /*message*/
          ctx2[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: "(68:3) <Message {appearance}>",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let message_1;
  let current;
  message_1 = new Message_default({
    props: {
      color: "danger",
      appearance: (
        /*appearance*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_1_changes = {};
      if (dirty & /*appearance*/
      8)
        message_1_changes.appearance = /*appearance*/
        ctx2[3];
      if (dirty & /*$$scope, error*/
      8256) {
        message_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      message_1.$set(message_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(message_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(72:2) {#if error}",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*error*/
        ctx[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*error*/
        ctx[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*error*/
      64)
        set_data_dev(
          t,
          /*error*/
          ctx2[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: '(73:3) <Message color=\\"danger\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let container;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  container = new Container_default({
    props: {
      direction: "vertical",
      gap: "large",
      appearance: (
        /*appearance*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_43] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block0 = (
    /*showLinks*/
    ctx[4] && create_if_block_23(ctx)
  );
  let if_block1 = (
    /*message*/
    ctx[5] && create_if_block_13(ctx)
  );
  let if_block2 = (
    /*error*/
    ctx[6] && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(container.$$.fragment, nodes);
      t0 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = {};
      if (dirty & /*appearance*/
      8)
        container_changes.appearance = /*appearance*/
        ctx2[3];
      if (dirty & /*$$scope, loading, appearance, i18n, email*/
      8334) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
      if (
        /*showLinks*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*showLinks*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_23(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*message*/
        ctx2[5]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*message*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_13(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*error*/
        ctx2[6]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*error*/
          64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block3(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: '(37:1) <Container direction=\\"vertical\\" gap=\\"large\\" {appearance}>',
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let form;
  let container;
  let current;
  let mounted;
  let dispose;
  container = new Container_default({
    props: {
      direction: "vertical",
      gap: "large",
      appearance: (
        /*appearance*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      form = element("form");
      create_component(container.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { id: true, method: true, class: true });
      var form_nodes = children(form);
      claim_component(container.$$.fragment, form_nodes);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(form, "id", "auth-magic-link");
      attr_dev(form, "method", "post");
      attr_dev(form, "class", "svelte-nm5p4o");
      add_location(form, file9, 35, 0, 994);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      mount_component(container, form, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(form, "submit", prevent_default(
          /*handleSubmit*/
          ctx[8]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const container_changes = {};
      if (dirty & /*appearance*/
      8)
        container_changes.appearance = /*appearance*/
        ctx2[3];
      if (dirty & /*$$scope, appearance, error, message, authView, i18n, showLinks, loading, email*/
      8447) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      destroy_component(container);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MagicLink", slots, []);
  let { i18n } = $$props;
  let { supabaseClient } = $$props;
  let { authView } = $$props;
  let { redirectTo = void 0 } = $$props;
  let { appearance } = $$props;
  let { showLinks = false } = $$props;
  let { email = "" } = $$props;
  let message = "";
  let error = "";
  let loading = false;
  async function handleSubmit() {
    var _a;
    $$invalidate(7, loading = true);
    $$invalidate(6, error = "");
    $$invalidate(5, message = "");
    const { error: resetPasswordError } = await supabaseClient.auth.signInWithOtp({
      email,
      options: { emailRedirectTo: redirectTo }
    });
    if (resetPasswordError)
      $$invalidate(6, error = resetPasswordError.message);
    else
      $$invalidate(5, message = (_a = i18n.magic_link) == null ? void 0 : _a.confirmation_text);
    $$invalidate(7, loading = false);
  }
  $$self.$$.on_mount.push(function() {
    if (i18n === void 0 && !("i18n" in $$props || $$self.$$.bound[$$self.$$.props["i18n"]])) {
      console.warn("<MagicLink> was created without expected prop 'i18n'");
    }
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<MagicLink> was created without expected prop 'supabaseClient'");
    }
    if (authView === void 0 && !("authView" in $$props || $$self.$$.bound[$$self.$$.props["authView"]])) {
      console.warn("<MagicLink> was created without expected prop 'authView'");
    }
    if (appearance === void 0 && !("appearance" in $$props || $$self.$$.bound[$$self.$$.props["appearance"]])) {
      console.warn("<MagicLink> was created without expected prop 'appearance'");
    }
  });
  const writable_props = [
    "i18n",
    "supabaseClient",
    "authView",
    "redirectTo",
    "appearance",
    "showLinks",
    "email"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MagicLink> was created with unknown prop '${key}'`);
  });
  function input_value_binding(value) {
    email = value;
    $$invalidate(1, email);
  }
  const click_handler = (e) => {
    e.preventDefault();
    $$invalidate(0, authView = VIEWS.SIGN_IN);
  };
  $$self.$$set = ($$props2) => {
    if ("i18n" in $$props2)
      $$invalidate(2, i18n = $$props2.i18n);
    if ("supabaseClient" in $$props2)
      $$invalidate(9, supabaseClient = $$props2.supabaseClient);
    if ("authView" in $$props2)
      $$invalidate(0, authView = $$props2.authView);
    if ("redirectTo" in $$props2)
      $$invalidate(10, redirectTo = $$props2.redirectTo);
    if ("appearance" in $$props2)
      $$invalidate(3, appearance = $$props2.appearance);
    if ("showLinks" in $$props2)
      $$invalidate(4, showLinks = $$props2.showLinks);
    if ("email" in $$props2)
      $$invalidate(1, email = $$props2.email);
  };
  $$self.$capture_state = () => ({
    Anchor: Anchor_default,
    Button: Button_default,
    Container: Container_default,
    Input: Input_default,
    Label: Label_default,
    Message: Message_default,
    VIEWS,
    i18n,
    supabaseClient,
    authView,
    redirectTo,
    appearance,
    showLinks,
    email,
    message,
    error,
    loading,
    handleSubmit
  });
  $$self.$inject_state = ($$props2) => {
    if ("i18n" in $$props2)
      $$invalidate(2, i18n = $$props2.i18n);
    if ("supabaseClient" in $$props2)
      $$invalidate(9, supabaseClient = $$props2.supabaseClient);
    if ("authView" in $$props2)
      $$invalidate(0, authView = $$props2.authView);
    if ("redirectTo" in $$props2)
      $$invalidate(10, redirectTo = $$props2.redirectTo);
    if ("appearance" in $$props2)
      $$invalidate(3, appearance = $$props2.appearance);
    if ("showLinks" in $$props2)
      $$invalidate(4, showLinks = $$props2.showLinks);
    if ("email" in $$props2)
      $$invalidate(1, email = $$props2.email);
    if ("message" in $$props2)
      $$invalidate(5, message = $$props2.message);
    if ("error" in $$props2)
      $$invalidate(6, error = $$props2.error);
    if ("loading" in $$props2)
      $$invalidate(7, loading = $$props2.loading);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    authView,
    email,
    i18n,
    appearance,
    showLinks,
    message,
    error,
    loading,
    handleSubmit,
    supabaseClient,
    redirectTo,
    input_value_binding,
    click_handler
  ];
}
var MagicLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance9,
      create_fragment9,
      safe_not_equal,
      {
        i18n: 2,
        supabaseClient: 9,
        authView: 0,
        redirectTo: 10,
        appearance: 3,
        showLinks: 4,
        email: 1
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MagicLink",
      options,
      id: create_fragment9.name
    });
  }
  get i18n() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set i18n(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get supabaseClient() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get authView() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set authView(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirectTo() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirectTo(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLinks() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLinks(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get email() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set email(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MagicLink_default = MagicLink;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/Icons.svelte
var file10 = "node_modules/@supabase/auth-ui-svelte/dist/Auth/Icons.svelte";
function add_css5(target) {
  append_styles(target, "svelte-10a6av0", "svg.svelte-10a6av0{height:21px;width:21px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSWNvbnMuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQStTQyxrQkFBSSxDQUNILE1BQU0sQ0FBRSxJQUFJLENBQ1osS0FBSyxDQUFFLElBQ1IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSWNvbnMuc3ZlbHRlIl19 */");
}
function create_if_block_15(ctx) {
  let svg;
  let path0;
  let path1;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M33 256.043C33 264.556 35.3159 273.069 39.4845 280.202L117.993 415.493C126.098 429.298 138.373 440.572 153.657 445.634C183.764 455.528 214.797 442.873 229.618 417.333L248.609 384.661L173.806 256.043L252.777 119.831L271.768 87.1591C277.557 77.2654 284.968 69.4424 294 63H285.894H172.185C150.878 63 131.193 74.2742 120.54 92.6812L39.7161 231.884C35.3159 239.016 33 247.53 33 256.043Z");
      attr_dev(path0, "fill", "#6363F1");
      add_location(path0, file10, 291, 2, 18165);
      attr_dev(path1, "d", "M480 256.058C480 247.539 477.684 239.021 473.516 231.883L393.849 94.6596C379.028 69.3331 347.995 56.4396 317.888 66.34C302.603 71.4053 290.329 82.6871 282.224 96.5015L264.391 127.354L339.194 256.058L260.223 392.131L241.232 424.825C235.443 434.495 228.032 442.553 219 449H227.106H340.815C362.122 449 381.807 437.718 392.46 419.299L473.284 280.003C477.684 272.866 480 264.577 480 256.058Z");
      attr_dev(path1, "fill", "#6363F1");
      add_location(path1, file10, 295, 2, 18585);
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "viewBox", "0 0 512 512");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 284, 1, 18049);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(284:32) ",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let path3;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path3).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M416 240L352 304H288L232 360V304H160V64H416V240Z");
      attr_dev(path0, "fill", "white");
      add_location(path0, file10, 275, 2, 17679);
      attr_dev(path1, "d", "M144 32L64 112V400H160V480L240 400H304L448 256V32H144ZM416 240L352 304H288L232 360V304H160V64H416V240Z");
      attr_dev(path1, "fill", "#9146FF");
      add_location(path1, file10, 276, 2, 17756);
      attr_dev(path2, "d", "M368 120H336V216H368V120Z");
      attr_dev(path2, "fill", "#9146FF");
      add_location(path2, file10, 280, 2, 17897);
      attr_dev(path3, "d", "M280 120H248V216H280V120Z");
      attr_dev(path3, "fill", "#9146FF");
      add_location(path3, file10, 281, 2, 17953);
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "viewBox", "0 0 512 512");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 268, 1, 17563);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, path3);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(268:32) ",
    ctx
  });
  return block;
}
function create_if_block_132(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M255.498 31.0034C131.513 31.0034 31 131.515 31 255.502C31 379.492 131.513 480 255.498 480C379.497 480 480 379.495 480 255.502C480 131.522 379.497 31.0135 255.495 31.0135L255.498 31V31.0034ZM358.453 354.798C354.432 361.391 345.801 363.486 339.204 359.435C286.496 327.237 220.139 319.947 141.993 337.801C134.463 339.516 126.957 334.798 125.24 327.264C123.516 319.731 128.217 312.225 135.767 310.511C221.284 290.972 294.639 299.384 353.816 335.549C360.413 339.596 362.504 348.2 358.453 354.798ZM385.932 293.67C380.864 301.903 370.088 304.503 361.858 299.438C301.512 262.345 209.528 251.602 138.151 273.272C128.893 276.067 119.118 270.851 116.309 261.61C113.521 252.353 118.74 242.597 127.981 239.782C209.512 215.044 310.87 227.026 380.17 269.612C388.4 274.68 391 285.456 385.935 293.676V293.673L385.932 293.67ZM388.293 230.016C315.935 187.039 196.56 183.089 127.479 204.055C116.387 207.42 104.654 201.159 101.293 190.063C97.9326 178.964 104.189 167.241 115.289 163.87C194.59 139.796 326.418 144.446 409.723 193.902C419.722 199.826 422.995 212.71 417.068 222.675C411.168 232.653 398.247 235.943 388.303 230.016H388.293V230.016Z");
      attr_dev(path, "fill", "#1ED760");
      add_location(path, file10, 262, 2, 16361);
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "viewBox", "0 0 512 512");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 255, 1, 16245);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_132.name,
    type: "if",
    source: "(255:33) ",
    ctx
  });
  return block;
}
function create_if_block_122(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let path3;
  let path4;
  let path5;
  let path6;
  let path7;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      path4 = svg_element("path");
      path5 = svg_element("path");
      path6 = svg_element("path");
      path7 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path3).forEach(detach_dev);
      path4 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path4).forEach(detach_dev);
      path5 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path5).forEach(detach_dev);
      path6 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path6).forEach(detach_dev);
      path7 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path7).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "fill", "#33d375");
      attr_dev(path0, "d", "M33,8c0-2.209-1.791-4-4-4s-4,1.791-4,4c0,1.254,0,9.741,0,11c0,2.209,1.791,4,4,4s4-1.791,4-4	C33,17.741,33,9.254,33,8z");
      add_location(path0, file10, 221, 2, 14990);
      attr_dev(path1, "fill", "#33d375");
      attr_dev(path1, "d", "M43,19c0,2.209-1.791,4-4,4c-1.195,0-4,0-4,0s0-2.986,0-4c0-2.209,1.791-4,4-4S43,16.791,43,19z");
      add_location(path1, file10, 225, 2, 15146);
      attr_dev(path2, "fill", "#40c4ff");
      attr_dev(path2, "d", "M8,14c-2.209,0-4,1.791-4,4s1.791,4,4,4c1.254,0,9.741,0,11,0c2.209,0,4-1.791,4-4s-1.791-4-4-4	C17.741,14,9.254,14,8,14z");
      add_location(path2, file10, 229, 2, 15277);
      attr_dev(path3, "fill", "#40c4ff");
      attr_dev(path3, "d", "M19,4c2.209,0,4,1.791,4,4c0,1.195,0,4,0,4s-2.986,0-4,0c-2.209,0-4-1.791-4-4S16.791,4,19,4z");
      add_location(path3, file10, 233, 2, 15434);
      attr_dev(path4, "fill", "#e91e63");
      attr_dev(path4, "d", "M14,39.006C14,41.212,15.791,43,18,43s4-1.788,4-3.994c0-1.252,0-9.727,0-10.984	c0-2.206-1.791-3.994-4-3.994s-4,1.788-4,3.994C14,29.279,14,37.754,14,39.006z");
      add_location(path4, file10, 237, 2, 15563);
      attr_dev(path5, "fill", "#e91e63");
      attr_dev(path5, "d", "M4,28.022c0-2.206,1.791-3.994,4-3.994c1.195,0,4,0,4,0s0,2.981,0,3.994c0,2.206-1.791,3.994-4,3.994	S4,30.228,4,28.022z");
      add_location(path5, file10, 241, 2, 15756);
      attr_dev(path6, "fill", "#ffc107");
      attr_dev(path6, "d", "M39,33c2.209,0,4-1.791,4-4s-1.791-4-4-4c-1.254,0-9.741,0-11,0c-2.209,0-4,1.791-4,4s1.791,4,4,4	C29.258,33,37.746,33,39,33z");
      add_location(path6, file10, 245, 2, 15912);
      attr_dev(path7, "fill", "#ffc107");
      attr_dev(path7, "d", "M28,43c-2.209,0-4-1.791-4-4c0-1.195,0-4,0-4s2.986,0,4,0c2.209,0,4,1.791,4,4S30.209,43,28,43z");
      add_location(path7, file10, 249, 2, 16073);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 48 48");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 220, 1, 14900);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, path3);
      append_hydration_dev(svg, path4);
      append_hydration_dev(svg, path5);
      append_hydration_dev(svg, path6);
      append_hydration_dev(svg, path7);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_122.name,
    type: "if",
    source: "(220:31) ",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        "fill-rule": true,
        "clip-rule": true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", {
        fill: true,
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", {
        fill: true,
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", {
        fill: true,
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children(path2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "fill", "#fff");
      attr_dev(path0, "fill-rule", "evenodd");
      attr_dev(path0, "d", "M11.553,11.099c1.232,1.001,1.694,0.925,4.008,0.77 l21.812-1.31c0.463,0,0.078-0.461-0.076-0.538l-3.622-2.619c-0.694-0.539-1.619-1.156-3.391-1.002l-21.12,1.54 c-0.77,0.076-0.924,0.461-0.617,0.77L11.553,11.099z");
      attr_dev(path0, "clip-rule", "evenodd");
      add_location(path0, file10, 200, 2, 13101);
      attr_dev(path1, "fill", "#fff");
      attr_dev(path1, "fill-rule", "evenodd");
      attr_dev(path1, "d", "M12.862,16.182v22.95c0,1.233,0.616,1.695,2.004,1.619 l23.971-1.387c1.388-0.076,1.543-0.925,1.543-1.927V14.641c0-1-0.385-1.54-1.234-1.463l-25.05,1.463 C13.171,14.718,12.862,15.181,12.862,16.182L12.862,16.182z");
      attr_dev(path1, "clip-rule", "evenodd");
      add_location(path1, file10, 206, 2, 13390);
      attr_dev(path2, "fill", "#424242");
      attr_dev(path2, "fill-rule", "evenodd");
      attr_dev(path2, "d", "M11.553,11.099c1.232,1.001,1.694,0.925,4.008,0.77 l21.812-1.31c0.463,0,0.078-0.461-0.076-0.538l-3.622-2.619c-0.694-0.539-1.619-1.156-3.391-1.002l-21.12,1.54 c-0.77,0.076-0.924,0.461-0.617,0.77L11.553,11.099z M12.862,16.182v22.95c0,1.233,0.616,1.695,2.004,1.619l23.971-1.387 c1.388-0.076,1.543-0.925,1.543-1.927V14.641c0-1-0.385-1.54-1.234-1.463l-25.05,1.463C13.171,14.718,12.862,15.181,12.862,16.182 L12.862,16.182z M36.526,17.413c0.154,0.694,0,1.387-0.695,1.465l-1.155,0.23v16.943c-1.003,0.539-1.928,0.847-2.698,0.847 c-1.234,0-1.543-0.385-2.467-1.54l-7.555-11.86v11.475l2.391,0.539c0,0,0,1.386-1.929,1.386l-5.317,0.308 c-0.154-0.308,0-1.078,0.539-1.232l1.388-0.385V20.418l-1.927-0.154c-0.155-0.694,0.23-1.694,1.31-1.772l5.704-0.385l7.862,12.015 V19.493l-2.005-0.23c-0.154-0.848,0.462-1.464,1.233-1.54L36.526,17.413z M7.389,5.862l21.968-1.618 c2.698-0.231,3.392-0.076,5.087,1.155l7.013,4.929C42.614,11.176,43,11.407,43,12.33v27.032c0,1.694-0.617,2.696-2.775,2.849 l-25.512,1.541c-1.62,0.077-2.391-0.154-3.239-1.232l-5.164-6.7C5.385,34.587,5,33.664,5,32.585V8.556 C5,7.171,5.617,6.015,7.389,5.862z");
      attr_dev(path2, "clip-rule", "evenodd");
      add_location(path2, file10, 212, 2, 13679);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 48 48");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "fill-rule", "evenodd");
      attr_dev(svg, "clip-rule", "evenodd");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 192, 1, 12957);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(192:32) ",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let svg;
  let path0;
  let path1;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "fill", "#0288D1");
      attr_dev(path0, "d", "M42,37c0,2.762-2.238,5-5,5H11c-2.761,0-5-2.238-5-5V11c0-2.762,2.239-5,5-5h26c2.762,0,5,2.238,5,5V37z");
      add_location(path0, file10, 182, 2, 12389);
      attr_dev(path1, "fill", "#FFF");
      attr_dev(path1, "d", "M12 19H17V36H12zM14.485 17h-.028C12.965 17 12 15.888 12 14.499 12 13.08 12.995 12 14.514 12c1.521 0 2.458 1.08 2.486 2.499C17 15.887 16.035 17 14.485 17zM36 36h-5v-9.099c0-2.198-1.225-3.698-3.192-3.698-1.501 0-2.313 1.012-2.707 1.99C24.957 25.543 25 26.511 25 27v9h-5V19h5v2.616C25.721 20.5 26.85 19 29.738 19c3.578 0 6.261 2.25 6.261 7.274L36 36 36 36z");
      add_location(path1, file10, 186, 2, 12528);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 48 48");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 181, 1, 12299);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(181:34) ",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true, fill: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M472.136 163.959H408.584C407.401 163.959 406.218 163.327 405.666 162.3L354.651 73.6591C354.02 72.632 352.916 72 351.654 72H143.492C142.309 72 141.126 72.632 140.574 73.6591L87.5084 165.618L36.414 254.259C35.862 255.286 35.862 256.55 36.414 257.656L87.5084 346.297L140.495 438.335C141.047 439.362 142.23 440.073 143.413 439.994H351.654C352.837 439.994 354.02 439.362 354.651 438.335L405.745 349.694C406.297 348.667 407.48 347.956 408.663 348.035H472.215C474.344 348.035 476 346.297 476 344.243V167.83C475.921 165.697 474.186 163.959 472.136 163.959ZM228.728 349.694L212.721 377.345C212.485 377.74 212.091 378.135 211.696 378.372C211.223 378.609 210.75 378.767 210.198 378.767H178.422C177.318 378.767 176.293 378.214 175.82 377.187L128.431 294.787L123.779 286.65L106.748 257.498C106.511 257.103 106.353 256.629 106.432 256.076C106.432 255.602 106.59 255.049 106.827 254.654L123.937 224.949L175.899 134.886C176.451 133.938 177.476 133.306 178.501 133.306H210.198C210.75 133.306 211.302 133.464 211.854 133.701C212.248 133.938 212.643 134.254 212.879 134.728L228.886 162.537C229.359 163.485 229.28 164.67 228.728 165.539L177.397 254.654C177.16 255.049 177.081 255.523 177.081 255.918C177.081 256.392 177.239 256.787 177.397 257.182L228.728 346.218C229.438 347.403 229.359 348.667 228.728 349.694V349.694ZM388.083 257.498L371.051 286.65L366.399 294.787L319.011 377.187C318.459 378.135 317.512 378.767 316.409 378.767H284.632C284.08 378.767 283.607 378.609 283.134 378.372C282.74 378.135 282.346 377.819 282.109 377.345L266.103 349.694C265.393 348.667 265.393 347.403 266.024 346.376L317.355 257.34C317.591 256.945 317.67 256.471 317.67 256.076C317.67 255.602 317.513 255.207 317.355 254.812L266.024 165.697C265.472 164.749 265.393 163.643 265.866 162.695L281.873 134.886C282.109 134.491 282.503 134.096 282.898 133.859C283.371 133.543 283.923 133.464 284.553 133.464H316.409C317.512 133.464 318.538 134.017 319.011 135.044L370.972 225.107L388.083 254.812C388.319 255.286 388.477 255.76 388.477 256.234C388.477 256.55 388.319 257.024 388.083 257.498V257.498Z");
      attr_dev(path, "fill", "#008AAA");
      add_location(path, file10, 175, 2, 10166);
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "viewBox", "0 0 512 512");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 168, 1, 10050);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(168:34) ",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let svg;
  let linearGradient0;
  let stop0;
  let stop1;
  let path0;
  let path1;
  let linearGradient1;
  let stop2;
  let stop3;
  let stop4;
  let stop5;
  let stop6;
  let path2;
  let linearGradient2;
  let stop7;
  let stop8;
  let path3;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      linearGradient0 = svg_element("linearGradient");
      stop0 = svg_element("stop");
      stop1 = svg_element("stop");
      path0 = svg_element("path");
      path1 = svg_element("path");
      linearGradient1 = svg_element("linearGradient");
      stop2 = svg_element("stop");
      stop3 = svg_element("stop");
      stop4 = svg_element("stop");
      stop5 = svg_element("stop");
      stop6 = svg_element("stop");
      path2 = svg_element("path");
      linearGradient2 = svg_element("linearGradient");
      stop7 = svg_element("stop");
      stop8 = svg_element("stop");
      path3 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      linearGradient0 = claim_svg_element(svg_nodes, "linearGradient", {
        id: true,
        x1: true,
        x2: true,
        y1: true,
        y2: true,
        gradientTransform: true,
        gradientUnits: true
      });
      var linearGradient0_nodes = children(linearGradient0);
      stop0 = claim_svg_element(linearGradient0_nodes, "stop", { offset: true, "stop-color": true });
      children(stop0).forEach(detach_dev);
      stop1 = claim_svg_element(linearGradient0_nodes, "stop", { offset: true, "stop-color": true });
      children(stop1).forEach(detach_dev);
      linearGradient0_nodes.forEach(detach_dev);
      path0 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path1).forEach(detach_dev);
      linearGradient1 = claim_svg_element(svg_nodes, "linearGradient", {
        id: true,
        x1: true,
        x2: true,
        y1: true,
        y2: true,
        gradientTransform: true,
        gradientUnits: true
      });
      var linearGradient1_nodes = children(linearGradient1);
      stop2 = claim_svg_element(linearGradient1_nodes, "stop", { offset: true, "stop-opacity": true });
      children(stop2).forEach(detach_dev);
      stop3 = claim_svg_element(linearGradient1_nodes, "stop", { offset: true, "stop-opacity": true });
      children(stop3).forEach(detach_dev);
      stop4 = claim_svg_element(linearGradient1_nodes, "stop", { offset: true, "stop-opacity": true });
      children(stop4).forEach(detach_dev);
      stop5 = claim_svg_element(linearGradient1_nodes, "stop", { offset: true, "stop-opacity": true });
      children(stop5).forEach(detach_dev);
      stop6 = claim_svg_element(linearGradient1_nodes, "stop", { offset: true, "stop-opacity": true });
      children(stop6).forEach(detach_dev);
      linearGradient1_nodes.forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path2).forEach(detach_dev);
      linearGradient2 = claim_svg_element(svg_nodes, "linearGradient", {
        id: true,
        x1: true,
        x2: true,
        y1: true,
        y2: true,
        gradientTransform: true,
        gradientUnits: true
      });
      var linearGradient2_nodes = children(linearGradient2);
      stop7 = claim_svg_element(linearGradient2_nodes, "stop", { offset: true, "stop-color": true });
      children(stop7).forEach(detach_dev);
      stop8 = claim_svg_element(linearGradient2_nodes, "stop", { offset: true, "stop-color": true });
      children(stop8).forEach(detach_dev);
      linearGradient2_nodes.forEach(detach_dev);
      path3 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path3).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(stop0, "offset", "0");
      attr_dev(stop0, "stop-color", "#114a8b");
      add_location(stop0, file10, 120, 3, 8035);
      attr_dev(stop1, "offset", "1");
      attr_dev(stop1, "stop-color", "#0669bc");
      add_location(stop1, file10, 121, 3, 8079);
      attr_dev(linearGradient0, "id", "k8yl7~hDat~FaoWq8WjN6a");
      attr_dev(linearGradient0, "x1", "-1254.397");
      attr_dev(linearGradient0, "x2", "-1261.911");
      attr_dev(linearGradient0, "y1", "877.268");
      attr_dev(linearGradient0, "y2", "899.466");
      attr_dev(linearGradient0, "gradientTransform", "translate(1981.75 -1362.063) scale(1.5625)");
      attr_dev(linearGradient0, "gradientUnits", "userSpaceOnUse");
      add_location(linearGradient0, file10, 111, 2, 7813);
      attr_dev(path0, "fill", "url(#k8yl7~hDat~FaoWq8WjN6a)");
      attr_dev(path0, "d", "M17.634,6h11.305L17.203,40.773c-0.247,0.733-0.934,1.226-1.708,1.226H6.697 c-0.994,0-1.8-0.806-1.8-1.8c0-0.196,0.032-0.39,0.094-0.576L15.926,7.227C16.173,6.494,16.86,6,17.634,6L17.634,6z");
      add_location(path0, file10, 123, 2, 8142);
      attr_dev(path1, "fill", "#0078d4");
      attr_dev(path1, "d", "M34.062,29.324H16.135c-0.458-0.001-0.83,0.371-0.831,0.829c0,0.231,0.095,0.451,0.264,0.608 l11.52,10.752C27.423,41.826,27.865,42,28.324,42h10.151L34.062,29.324z");
      add_location(path1, file10, 127, 2, 8387);
      attr_dev(stop2, "offset", "0");
      attr_dev(stop2, "stop-opacity", ".3");
      add_location(stop2, file10, 140, 3, 8804);
      attr_dev(stop3, "offset", ".071");
      attr_dev(stop3, "stop-opacity", ".2");
      add_location(stop3, file10, 141, 3, 8845);
      attr_dev(stop4, "offset", ".321");
      attr_dev(stop4, "stop-opacity", ".1");
      add_location(stop4, file10, 142, 3, 8889);
      attr_dev(stop5, "offset", ".623");
      attr_dev(stop5, "stop-opacity", ".05");
      add_location(stop5, file10, 143, 3, 8933);
      attr_dev(stop6, "offset", "1");
      attr_dev(stop6, "stop-opacity", "0");
      add_location(stop6, file10, 144, 3, 8978);
      attr_dev(linearGradient1, "id", "k8yl7~hDat~FaoWq8WjN6b");
      attr_dev(linearGradient1, "x1", "-1252.05");
      attr_dev(linearGradient1, "x2", "-1253.788");
      attr_dev(linearGradient1, "y1", "887.612");
      attr_dev(linearGradient1, "y2", "888.2");
      attr_dev(linearGradient1, "gradientTransform", "translate(1981.75 -1362.063) scale(1.5625)");
      attr_dev(linearGradient1, "gradientUnits", "userSpaceOnUse");
      add_location(linearGradient1, file10, 131, 2, 8585);
      attr_dev(path2, "fill", "url(#k8yl7~hDat~FaoWq8WjN6b)");
      attr_dev(path2, "d", "M17.634,6c-0.783-0.003-1.476,0.504-1.712,1.25L5.005,39.595 c-0.335,0.934,0.151,1.964,1.085,2.299C6.286,41.964,6.493,42,6.702,42h9.026c0.684-0.122,1.25-0.603,1.481-1.259l2.177-6.416 l7.776,7.253c0.326,0.27,0.735,0.419,1.158,0.422h10.114l-4.436-12.676l-12.931,0.003L28.98,6H17.634z");
      add_location(path2, file10, 146, 2, 9037);
      attr_dev(stop7, "offset", "0");
      attr_dev(stop7, "stop-color", "#3ccbf4");
      add_location(stop7, file10, 159, 3, 9596);
      attr_dev(stop8, "offset", "1");
      attr_dev(stop8, "stop-color", "#2892df");
      add_location(stop8, file10, 160, 3, 9640);
      attr_dev(linearGradient2, "id", "k8yl7~hDat~FaoWq8WjN6c");
      attr_dev(linearGradient2, "x1", "-1252.952");
      attr_dev(linearGradient2, "x2", "-1244.704");
      attr_dev(linearGradient2, "y1", "876.6");
      attr_dev(linearGradient2, "y2", "898.575");
      attr_dev(linearGradient2, "gradientTransform", "translate(1981.75 -1362.063) scale(1.5625)");
      attr_dev(linearGradient2, "gradientUnits", "userSpaceOnUse");
      add_location(linearGradient2, file10, 150, 2, 9376);
      attr_dev(path3, "fill", "url(#k8yl7~hDat~FaoWq8WjN6c)");
      attr_dev(path3, "d", "M32.074,7.225C31.827,6.493,31.141,6,30.368,6h-12.6c0.772,0,1.459,0.493,1.705,1.224 l10.935,32.399c0.318,0.942-0.188,1.963-1.13,2.281C29.093,41.968,28.899,42,28.703,42h12.6c0.994,0,1.8-0.806,1.8-1.801 c0-0.196-0.032-0.39-0.095-0.575L32.074,7.225z");
      add_location(path3, file10, 162, 2, 9703);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 48 48");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 110, 1, 7723);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, linearGradient0);
      append_hydration_dev(linearGradient0, stop0);
      append_hydration_dev(linearGradient0, stop1);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, linearGradient1);
      append_hydration_dev(linearGradient1, stop2);
      append_hydration_dev(linearGradient1, stop3);
      append_hydration_dev(linearGradient1, stop4);
      append_hydration_dev(linearGradient1, stop5);
      append_hydration_dev(linearGradient1, stop6);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, linearGradient2);
      append_hydration_dev(linearGradient2, stop7);
      append_hydration_dev(linearGradient2, stop8);
      append_hydration_dev(svg, path3);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(110:31) ",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "#536dfe");
      attr_dev(path, "d", "M39.248,10.177c-2.804-1.287-5.812-2.235-8.956-2.778c-0.057-0.01-0.114,0.016-0.144,0.068	c-0.387,0.688-0.815,1.585-1.115,2.291c-3.382-0.506-6.747-0.506-10.059,0c-0.3-0.721-0.744-1.603-1.133-2.291	c-0.03-0.051-0.087-0.077-0.144-0.068c-3.143,0.541-6.15,1.489-8.956,2.778c-0.024,0.01-0.045,0.028-0.059,0.051	c-5.704,8.522-7.267,16.835-6.5,25.044c0.003,0.04,0.026,0.079,0.057,0.103c3.763,2.764,7.409,4.442,10.987,5.554	c0.057,0.017,0.118-0.003,0.154-0.051c0.846-1.156,1.601-2.374,2.248-3.656c0.038-0.075,0.002-0.164-0.076-0.194	c-1.197-0.454-2.336-1.007-3.432-1.636c-0.087-0.051-0.094-0.175-0.014-0.234c0.231-0.173,0.461-0.353,0.682-0.534	c0.04-0.033,0.095-0.04,0.142-0.019c7.201,3.288,14.997,3.288,22.113,0c0.047-0.023,0.102-0.016,0.144,0.017	c0.22,0.182,0.451,0.363,0.683,0.536c0.08,0.059,0.075,0.183-0.012,0.234c-1.096,0.641-2.236,1.182-3.434,1.634	c-0.078,0.03-0.113,0.12-0.075,0.196c0.661,1.28,1.415,2.498,2.246,3.654c0.035,0.049,0.097,0.07,0.154,0.052	c3.595-1.112,7.241-2.79,11.004-5.554c0.033-0.024,0.054-0.061,0.057-0.101c0.917-9.491-1.537-17.735-6.505-25.044	C39.293,10.205,39.272,10.187,39.248,10.177z M16.703,30.273c-2.168,0-3.954-1.99-3.954-4.435s1.752-4.435,3.954-4.435	c2.22,0,3.989,2.008,3.954,4.435C20.658,28.282,18.906,30.273,16.703,30.273z M31.324,30.273c-2.168,0-3.954-1.99-3.954-4.435	s1.752-4.435,3.954-4.435c2.22,0,3.989,2.008,3.954,4.435C35.278,28.282,33.544,30.273,31.324,30.273z");
      add_location(path, file10, 104, 2, 6246);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 48 48");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 103, 1, 6156);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(103:33) ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let svg;
  let defs;
  let linearGradient;
  let stop0;
  let stop1;
  let title;
  let t;
  let g1;
  let g0;
  let path0;
  let path1;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      defs = svg_element("defs");
      linearGradient = svg_element("linearGradient");
      stop0 = svg_element("stop");
      stop1 = svg_element("stop");
      title = svg_element("title");
      t = text("Bitbucket-blue");
      g1 = svg_element("g");
      g0 = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        class: true
      });
      var svg_nodes = children(svg);
      defs = claim_svg_element(svg_nodes, "defs", {});
      var defs_nodes = children(defs);
      linearGradient = claim_svg_element(defs_nodes, "linearGradient", {
        id: true,
        x1: true,
        y1: true,
        x2: true,
        y2: true,
        gradientUnits: true
      });
      var linearGradient_nodes = children(linearGradient);
      stop0 = claim_svg_element(linearGradient_nodes, "stop", { offset: true, "stop-color": true });
      children(stop0).forEach(detach_dev);
      stop1 = claim_svg_element(linearGradient_nodes, "stop", { offset: true, "stop-color": true });
      children(stop1).forEach(detach_dev);
      linearGradient_nodes.forEach(detach_dev);
      defs_nodes.forEach(detach_dev);
      title = claim_svg_element(svg_nodes, "title", {});
      var title_nodes = children(title);
      t = claim_text(title_nodes, "Bitbucket-blue");
      title_nodes.forEach(detach_dev);
      g1 = claim_svg_element(svg_nodes, "g", { id: true, "data-name": true });
      var g1_nodes = children(g1);
      g0 = claim_svg_element(g1_nodes, "g", { id: true, transform: true });
      var g0_nodes = children(g0);
      path0 = claim_svg_element(g0_nodes, "path", { d: true, fill: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(g0_nodes, "path", { d: true, fill: true });
      children(path1).forEach(detach_dev);
      g0_nodes.forEach(detach_dev);
      g1_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(stop0, "offset", "0.18");
      attr_dev(stop0, "stop-color", "#0052cc");
      add_location(stop0, file10, 84, 4, 5507);
      attr_dev(stop1, "offset", "1");
      attr_dev(stop1, "stop-color", "#2684ff");
      add_location(stop1, file10, 85, 4, 5555);
      attr_dev(linearGradient, "id", "New_Gradient_Swatch_1");
      attr_dev(linearGradient, "x1", "64.01");
      attr_dev(linearGradient, "y1", "30.27");
      attr_dev(linearGradient, "x2", "32.99");
      attr_dev(linearGradient, "y2", "54.48");
      attr_dev(linearGradient, "gradientUnits", "userSpaceOnUse");
      add_location(linearGradient, file10, 76, 3, 5356);
      add_location(defs, file10, 75, 2, 5346);
      add_location(title, file10, 88, 2, 5629);
      attr_dev(path0, "d", "M2,6.26A2,2,0,0,0,0,8.58L8.49,60.12a2.72,2.72,0,0,0,2.66,2.27H51.88a2,2,0,0,0,2-1.68L62.37,8.59a2,2,0,0,0-2-2.32ZM37.75,43.51h-13L21.23,25.12H40.9Z");
      attr_dev(path0, "fill", "#2684ff");
      add_location(path0, file10, 91, 4, 5750);
      attr_dev(path1, "d", "M59.67,25.12H40.9L37.75,43.51h-13L9.4,61.73a2.71,2.71,0,0,0,1.75.66H51.89a2,2,0,0,0,2-1.68Z");
      attr_dev(path1, "fill", "url(#New_Gradient_Swatch_1)");
      add_location(path1, file10, 95, 4, 5944);
      attr_dev(g0, "id", "Blue");
      attr_dev(g0, "transform", "translate(0 -3.13)");
      add_location(g0, file10, 90, 3, 5701);
      attr_dev(g1, "id", "Layer_2");
      attr_dev(g1, "data-name", "Layer 2");
      add_location(g1, file10, 89, 2, 5661);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "viewBox", "0 0 62.42 62.42");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 74, 1, 5250);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, defs);
      append_hydration_dev(defs, linearGradient);
      append_hydration_dev(linearGradient, stop0);
      append_hydration_dev(linearGradient, stop1);
      append_hydration_dev(svg, title);
      append_hydration_dev(title, t);
      append_hydration_dev(svg, g1);
      append_hydration_dev(g1, g0);
      append_hydration_dev(g0, path0);
      append_hydration_dev(g0, path1);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(74:35) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let path3;
  let path4;
  let path5;
  let path6;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      path4 = svg_element("path");
      path5 = svg_element("path");
      path6 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path3).forEach(detach_dev);
      path4 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path4).forEach(detach_dev);
      path5 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path5).forEach(detach_dev);
      path6 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path6).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "fill", "#e53935");
      attr_dev(path0, "d", "M24 43L16 20 32 20z");
      add_location(path0, file10, 65, 2, 4863);
      attr_dev(path1, "fill", "#ff7043");
      attr_dev(path1, "d", "M24 43L42 20 32 20z");
      add_location(path1, file10, 66, 2, 4913);
      attr_dev(path2, "fill", "#e53935");
      attr_dev(path2, "d", "M37 5L42 20 32 20z");
      add_location(path2, file10, 67, 2, 4963);
      attr_dev(path3, "fill", "#ffa726");
      attr_dev(path3, "d", "M24 43L42 20 45 28z");
      add_location(path3, file10, 68, 2, 5012);
      attr_dev(path4, "fill", "#ff7043");
      attr_dev(path4, "d", "M24 43L6 20 16 20z");
      add_location(path4, file10, 69, 2, 5062);
      attr_dev(path5, "fill", "#e53935");
      attr_dev(path5, "d", "M11 5L6 20 16 20z");
      add_location(path5, file10, 70, 2, 5111);
      attr_dev(path6, "fill", "#ffa726");
      attr_dev(path6, "d", "M24 43L6 20 3 28z");
      add_location(path6, file10, 71, 2, 5159);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 48 48");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 64, 1, 4773);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, path3);
      append_hydration_dev(svg, path4);
      append_hydration_dev(svg, path5);
      append_hydration_dev(svg, path6);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(64:32) ",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let svg;
  let t_value = " ";
  let t;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      t = text(t_value);
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        fill: true,
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      t = claim_text(svg_nodes, t_value);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15,3C8.373,3,3,8.373,3,15c0,5.623,3.872,10.328,9.092,11.63C12.036,26.468,12,26.28,12,26.047v-2.051 c-0.487,0-1.303,0-1.508,0c-0.821,0-1.551-0.353-1.905-1.009c-0.393-0.729-0.461-1.844-1.435-2.526 c-0.289-0.227-0.069-0.486,0.264-0.451c0.615,0.174,1.125,0.596,1.605,1.222c0.478,0.627,0.703,0.769,1.596,0.769 c0.433,0,1.081-0.025,1.691-0.121c0.328-0.833,0.895-1.6,1.588-1.962c-3.996-0.411-5.903-2.399-5.903-5.098 c0-1.162,0.495-2.286,1.336-3.233C9.053,10.647,8.706,8.73,9.435,8c1.798,0,2.885,1.166,3.146,1.481C13.477,9.174,14.461,9,15.495,9 c1.036,0,2.024,0.174,2.922,0.483C18.675,9.17,19.763,8,21.565,8c0.732,0.731,0.381,2.656,0.102,3.594 c0.836,0.945,1.328,2.066,1.328,3.226c0,2.697-1.904,4.684-5.894,5.097C18.199,20.49,19,22.1,19,23.313v2.734 c0,0.104-0.023,0.179-0.035,0.268C23.641,24.676,27,20.236,27,15C27,8.373,21.627,3,15,3z");
      add_location(path, file10, 59, 2, 3883);
      attr_dev(svg, "fill", "gray");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 30 30");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 51, 1, 3761);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, t);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(51:32) ",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let svg;
  let t_value = " ";
  let t;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      t = text(t_value);
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        fill: true,
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      t = claim_text(svg_nodes, t_value);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M 15.904297 1.078125 C 15.843359 1.06875 15.774219 1.0746094 15.699219 1.0996094 C 14.699219 1.2996094 13.600391 1.8996094 12.900391 2.5996094 C 12.300391 3.1996094 11.800781 4.1996094 11.800781 5.0996094 C 11.800781 5.2996094 11.999219 5.5 12.199219 5.5 C 13.299219 5.4 14.399609 4.7996094 15.099609 4.0996094 C 15.699609 3.2996094 16.199219 2.4 16.199219 1.5 C 16.199219 1.275 16.087109 1.10625 15.904297 1.078125 z M 16.199219 5.4003906 C 14.399219 5.4003906 13.600391 6.5 12.400391 6.5 C 11.100391 6.5 9.9003906 5.5 8.4003906 5.5 C 6.3003906 5.5 3.0996094 7.4996094 3.0996094 12.099609 C 2.9996094 16.299609 6.8 21 9 21 C 10.3 21 10.600391 20.199219 12.400391 20.199219 C 14.200391 20.199219 14.600391 21 15.900391 21 C 17.400391 21 18.500391 19.399609 19.400391 18.099609 C 19.800391 17.399609 20.100391 17.000391 20.400391 16.400391 C 20.600391 16.000391 20.4 15.600391 20 15.400391 C 17.4 14.100391 16.900781 9.9003906 19.800781 8.4003906 C 20.300781 8.1003906 20.4 7.4992188 20 7.1992188 C 18.9 6.1992187 17.299219 5.4003906 16.199219 5.4003906 z");
      add_location(path, file10, 46, 2, 2646);
      attr_dev(svg, "fill", "gray");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 38, 1, 2524);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, t);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(38:31) ",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "#03A9F4");
      attr_dev(path, "d", "M42,12.429c-1.323,0.586-2.746,0.977-4.247,1.162c1.526-0.906,2.7-2.351,3.251-4.058c-1.428,0.837-3.01,1.452-4.693,1.776C34.967,9.884,33.05,9,30.926,9c-4.08,0-7.387,3.278-7.387,7.32c0,0.572,0.067,1.129,0.193,1.67c-6.138-0.308-11.582-3.226-15.224-7.654c-0.64,1.082-1,2.349-1,3.686c0,2.541,1.301,4.778,3.285,6.096c-1.211-0.037-2.351-0.374-3.349-0.914c0,0.022,0,0.055,0,0.086c0,3.551,2.547,6.508,5.923,7.181c-0.617,0.169-1.269,0.263-1.941,0.263c-0.477,0-0.942-0.054-1.392-0.135c0.94,2.902,3.667,5.023,6.898,5.086c-2.528,1.96-5.712,3.134-9.174,3.134c-0.598,0-1.183-0.034-1.761-0.104C9.268,36.786,13.152,38,17.321,38c13.585,0,21.017-11.156,21.017-20.834c0-0.317-0.01-0.633-0.025-0.945C39.763,15.197,41.013,13.905,42,12.429");
      add_location(path, file10, 32, 2, 1732);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 48 48");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 31, 1, 1642);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(31:33) ",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let svg;
  let path0;
  let path1;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "fill", "#039be5");
      attr_dev(path0, "d", "M24 5A19 19 0 1 0 24 43A19 19 0 1 0 24 5Z");
      add_location(path0, file10, 24, 2, 1233);
      attr_dev(path1, "fill", "#fff");
      attr_dev(path1, "d", "M26.572,29.036h4.917l0.772-4.995h-5.69v-2.73c0-2.075,0.678-3.915,2.619-3.915h3.119v-4.359c-0.548-0.074-1.707-0.236-3.897-0.236c-4.573,0-7.254,2.415-7.254,7.917v3.323h-4.701v4.995h4.701v13.729C22.089,42.905,23.032,43,24,43c0.875,0,1.729-0.08,2.572-0.194V29.036z");
      add_location(path1, file10, 25, 2, 1305);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 48 48");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 23, 1, 1143);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(23:34) ",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let path3;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      path0 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path3).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "fill", "#FFC107");
      attr_dev(path0, "d", "M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z");
      add_location(path0, file10, 5, 2, 159);
      attr_dev(path1, "fill", "#FF3D00");
      attr_dev(path1, "d", "M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z");
      add_location(path1, file10, 9, 2, 486);
      attr_dev(path2, "fill", "#4CAF50");
      attr_dev(path2, "d", "M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z");
      add_location(path2, file10, 13, 2, 686);
      attr_dev(path3, "fill", "#1976D2");
      attr_dev(path3, "d", "M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.571c0.001-0.001,0.002-0.001,0.003-0.002l6.19,5.238C36.971,39.205,44,34,44,24C44,22.659,43.862,21.35,43.611,20.083z");
      add_location(path3, file10, 17, 2, 882);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 48 48");
      attr_dev(svg, "width", "21px");
      attr_dev(svg, "height", "21px");
      attr_dev(svg, "class", "svelte-10a6av0");
      add_location(svg, file10, 4, 1, 69);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
      append_hydration_dev(svg, path3);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(4:0) {#if provider === 'google'}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*provider*/
      ctx2[0] === "google"
    )
      return create_if_block4;
    if (
      /*provider*/
      ctx2[0] === "facebook"
    )
      return create_if_block_16;
    if (
      /*provider*/
      ctx2[0] === "twitter"
    )
      return create_if_block_24;
    if (
      /*provider*/
      ctx2[0] === "apple"
    )
      return create_if_block_32;
    if (
      /*provider*/
      ctx2[0] === "github"
    )
      return create_if_block_42;
    if (
      /*provider*/
      ctx2[0] === "gitlab"
    )
      return create_if_block_5;
    if (
      /*provider*/
      ctx2[0] === "bitbucket"
    )
      return create_if_block_6;
    if (
      /*provider*/
      ctx2[0] === "discord"
    )
      return create_if_block_7;
    if (
      /*provider*/
      ctx2[0] === "azure"
    )
      return create_if_block_8;
    if (
      /*provider*/
      ctx2[0] === "keycloak"
    )
      return create_if_block_9;
    if (
      /*provider*/
      ctx2[0] === "linkedin"
    )
      return create_if_block_10;
    if (
      /*provider*/
      ctx2[0] === "notion"
    )
      return create_if_block_11;
    if (
      /*provider*/
      ctx2[0] === "slack"
    )
      return create_if_block_122;
    if (
      /*provider*/
      ctx2[0] === "spotify"
    )
      return create_if_block_132;
    if (
      /*provider*/
      ctx2[0] === "twitch"
    )
      return create_if_block_14;
    if (
      /*provider*/
      ctx2[0] === "workos"
    )
      return create_if_block_15;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icons", slots, []);
  let { provider } = $$props;
  $$self.$$.on_mount.push(function() {
    if (provider === void 0 && !("provider" in $$props || $$self.$$.bound[$$self.$$.props["provider"]])) {
      console.warn("<Icons> was created without expected prop 'provider'");
    }
  });
  const writable_props = ["provider"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Icons> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("provider" in $$props2)
      $$invalidate(0, provider = $$props2.provider);
  };
  $$self.$capture_state = () => ({ provider });
  $$self.$inject_state = ($$props2) => {
    if ("provider" in $$props2)
      $$invalidate(0, provider = $$props2.provider);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [provider];
}
var Icons = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { provider: 0 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icons",
      options,
      id: create_fragment10.name
    });
  }
  get provider() {
    throw new Error("<Icons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set provider(value) {
    throw new Error("<Icons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icons_default = Icons;

// node_modules/@supabase/auth-ui-svelte/dist/UI/Divider.svelte
var file11 = "node_modules/@supabase/auth-ui-svelte/dist/UI/Divider.svelte";
function create_fragment11(ctx) {
  var _a, _b;
  let div;
  let div_style_value;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2],
    {
      style: div_style_value = /*appearance*/
      (_b = (_a = ctx[0]) == null ? void 0 : _a.style) == null ? void 0 : _b.divider
    },
    {
      class: div_class_value = /*classNames*/
      ctx[1].join(" ")
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true, class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file11, 13, 0, 392);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      var _a2, _b2;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*appearance*/
        1 && div_style_value !== (div_style_value = /*appearance*/
        (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.style) == null ? void 0 : _b2.divider)) && { style: div_style_value },
        { class: div_class_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = ["appearance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Divider", slots, ["default"]);
  const dividerDefaultStyles = _({
    background: "$dividerBackground",
    display: "block",
    margin: "16px 0",
    height: "1px",
    width: "100%"
  });
  let { appearance = {} } = $$props;
  const classNames = generateClassNames("divider", dividerDefaultStyles(), appearance);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("appearance" in $$new_props)
      $$invalidate(0, appearance = $$new_props.appearance);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    css: _,
    generateClassNames,
    dividerDefaultStyles,
    appearance,
    classNames
  });
  $$self.$inject_state = ($$new_props) => {
    if ("appearance" in $$props)
      $$invalidate(0, appearance = $$new_props.appearance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [appearance, classNames, $$restProps, $$scope, slots];
}
var Divider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { appearance: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Divider",
      options,
      id: create_fragment11.name
    });
  }
  get appearance() {
    throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Divider_default = Divider;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/interfaces/SocialAuth.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
function create_if_block5(ctx) {
  let container;
  let t;
  let if_block_anchor;
  let current;
  container = new Container_default({
    props: {
      direction: "vertical",
      gap: "large",
      appearance: (
        /*appearance*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block = !/*onlyThirdPartyProviders*/
  ctx[0] && create_if_block_17(ctx);
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(container.$$.fragment, nodes);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = {};
      if (dirty & /*appearance*/
      4)
        container_changes.appearance = /*appearance*/
        ctx2[2];
      if (dirty & /*$$scope, verticalSocialLayout, appearance, providers, loading*/
      262174) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
      if (!/*onlyThirdPartyProviders*/
      ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*onlyThirdPartyProviders*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_17(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(41:0) {#if providers.length}",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let t_value = (
    /*iconTitle*/
    ctx[6](
      /*provider*/
      ctx[15]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*providers*/
      2 && t_value !== (t_value = /*iconTitle*/
      ctx2[6](
        /*provider*/
        ctx2[15]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(58:5) {#if verticalSocialLayout}",
    ctx
  });
  return block;
}
function create_default_slot_24(ctx) {
  let icons;
  let t0;
  let t1;
  let current;
  icons = new Icons_default({
    props: { provider: (
      /*provider*/
      ctx[15]
    ) },
    $$inline: true
  });
  let if_block = (
    /*verticalSocialLayout*/
    ctx[4] && create_if_block_25(ctx)
  );
  const block = {
    c: function create() {
      create_component(icons.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
    },
    l: function claim(nodes) {
      claim_component(icons.$$.fragment, nodes);
      t0 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      t1 = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(icons, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const icons_changes = {};
      if (dirty & /*providers*/
      2)
        icons_changes.provider = /*provider*/
        ctx2[15];
      icons.$set(icons_changes);
      if (
        /*verticalSocialLayout*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_25(ctx2);
          if_block.c();
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(icons, detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_24.name,
    type: "slot",
    source: '(49:4) <Button      aria-label={iconTitle(provider)}      on:click={() => handleProviderSignIn(provider)}      type=\\"submit\\"      color=\\"default\\"      {loading}      {appearance}     >',
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let button;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[13](
        /*provider*/
        ctx[15]
      )
    );
  }
  button = new Button_default({
    props: {
      "aria-label": (
        /*iconTitle*/
        ctx[6](
          /*provider*/
          ctx[15]
        )
      ),
      type: "submit",
      color: "default",
      loading: (
        /*loading*/
        ctx[3]
      ),
      appearance: (
        /*appearance*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", click_handler);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*providers*/
      2)
        button_changes["aria-label"] = /*iconTitle*/
        ctx[6](
          /*provider*/
          ctx[15]
        );
      if (dirty & /*loading*/
      8)
        button_changes.loading = /*loading*/
        ctx[3];
      if (dirty & /*appearance*/
      4)
        button_changes.appearance = /*appearance*/
        ctx[2];
      if (dirty & /*$$scope, providers, verticalSocialLayout*/
      262162) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(48:3) {#each providers as provider}",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*providers*/
    ctx[1]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*iconTitle, providers, loading, appearance, handleProviderSignIn, verticalSocialLayout*/
      126) {
        each_value = /*providers*/
        ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(43:2) <Container    direction={verticalSocialLayout ? 'vertical' : 'horizontal'}    gap={verticalSocialLayout ? 'small' : 'medium'}    {appearance}   >",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let container;
  let current;
  container = new Container_default({
    props: {
      direction: (
        /*verticalSocialLayout*/
        ctx[4] ? "vertical" : "horizontal"
      ),
      gap: (
        /*verticalSocialLayout*/
        ctx[4] ? "small" : "medium"
      ),
      appearance: (
        /*appearance*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(container.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = {};
      if (dirty & /*verticalSocialLayout*/
      16)
        container_changes.direction = /*verticalSocialLayout*/
        ctx2[4] ? "vertical" : "horizontal";
      if (dirty & /*verticalSocialLayout*/
      16)
        container_changes.gap = /*verticalSocialLayout*/
        ctx2[4] ? "small" : "medium";
      if (dirty & /*appearance*/
      4)
        container_changes.appearance = /*appearance*/
        ctx2[2];
      if (dirty & /*$$scope, providers, loading, appearance, verticalSocialLayout*/
      262174) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: '(42:1) <Container direction=\\"vertical\\" gap=\\"large\\" {appearance}>',
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let divider;
  let current;
  divider = new Divider_default({
    props: { appearance: (
      /*appearance*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(divider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(divider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(divider, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const divider_changes = {};
      if (dirty & /*appearance*/
      4)
        divider_changes.appearance = /*appearance*/
        ctx2[2];
      divider.$set(divider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(divider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(divider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(divider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(65:1) {#if !onlyThirdPartyProviders}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*providers*/
    ctx[1].length && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*providers*/
        ctx2[1].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*providers*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function capitalize(word) {
  return word[0].toUpperCase() + word.slice(1).toLowerCase();
}
function instance12($$self, $$props, $$invalidate) {
  let verticalSocialLayout;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SocialAuth", slots, []);
  let { supabaseClient } = $$props;
  let { socialLayout } = $$props;
  let { redirectTo = void 0 } = $$props;
  let { onlyThirdPartyProviders } = $$props;
  let { i18n } = $$props;
  let { providers = [] } = $$props;
  let { providerScopes } = $$props;
  let { queryParams } = $$props;
  let { appearance } = $$props;
  let error = "";
  let loading = false;
  async function handleProviderSignIn(provider) {
    $$invalidate(3, loading = true);
    error = "";
    const { error: providerSigninError } = await supabaseClient.auth.signInWithOAuth({
      provider,
      options: {
        redirectTo,
        scopes: providerScopes == null ? void 0 : providerScopes[provider],
        queryParams
      }
    });
    if (providerSigninError)
      error = providerSigninError.message;
    $$invalidate(3, loading = false);
  }
  let iconTitle = (provider) => {
    var _a;
    return template((_a = i18n["sign_in"]) == null ? void 0 : _a.social_provider_text, { provider: capitalize(provider) });
  };
  $$self.$$.on_mount.push(function() {
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<SocialAuth> was created without expected prop 'supabaseClient'");
    }
    if (socialLayout === void 0 && !("socialLayout" in $$props || $$self.$$.bound[$$self.$$.props["socialLayout"]])) {
      console.warn("<SocialAuth> was created without expected prop 'socialLayout'");
    }
    if (onlyThirdPartyProviders === void 0 && !("onlyThirdPartyProviders" in $$props || $$self.$$.bound[$$self.$$.props["onlyThirdPartyProviders"]])) {
      console.warn("<SocialAuth> was created without expected prop 'onlyThirdPartyProviders'");
    }
    if (i18n === void 0 && !("i18n" in $$props || $$self.$$.bound[$$self.$$.props["i18n"]])) {
      console.warn("<SocialAuth> was created without expected prop 'i18n'");
    }
    if (providerScopes === void 0 && !("providerScopes" in $$props || $$self.$$.bound[$$self.$$.props["providerScopes"]])) {
      console.warn("<SocialAuth> was created without expected prop 'providerScopes'");
    }
    if (queryParams === void 0 && !("queryParams" in $$props || $$self.$$.bound[$$self.$$.props["queryParams"]])) {
      console.warn("<SocialAuth> was created without expected prop 'queryParams'");
    }
    if (appearance === void 0 && !("appearance" in $$props || $$self.$$.bound[$$self.$$.props["appearance"]])) {
      console.warn("<SocialAuth> was created without expected prop 'appearance'");
    }
  });
  const writable_props = [
    "supabaseClient",
    "socialLayout",
    "redirectTo",
    "onlyThirdPartyProviders",
    "i18n",
    "providers",
    "providerScopes",
    "queryParams",
    "appearance"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SocialAuth> was created with unknown prop '${key}'`);
  });
  const click_handler = (provider) => handleProviderSignIn(provider);
  $$self.$$set = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(7, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(8, socialLayout = $$props2.socialLayout);
    if ("redirectTo" in $$props2)
      $$invalidate(9, redirectTo = $$props2.redirectTo);
    if ("onlyThirdPartyProviders" in $$props2)
      $$invalidate(0, onlyThirdPartyProviders = $$props2.onlyThirdPartyProviders);
    if ("i18n" in $$props2)
      $$invalidate(10, i18n = $$props2.i18n);
    if ("providers" in $$props2)
      $$invalidate(1, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(11, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(12, queryParams = $$props2.queryParams);
    if ("appearance" in $$props2)
      $$invalidate(2, appearance = $$props2.appearance);
  };
  $$self.$capture_state = () => ({
    template,
    Button: Button_default,
    Container: Container_default,
    Icons: Icons_default,
    Divider: Divider_default,
    supabaseClient,
    socialLayout,
    redirectTo,
    onlyThirdPartyProviders,
    i18n,
    providers,
    providerScopes,
    queryParams,
    appearance,
    error,
    loading,
    handleProviderSignIn,
    capitalize,
    iconTitle,
    verticalSocialLayout
  });
  $$self.$inject_state = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(7, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(8, socialLayout = $$props2.socialLayout);
    if ("redirectTo" in $$props2)
      $$invalidate(9, redirectTo = $$props2.redirectTo);
    if ("onlyThirdPartyProviders" in $$props2)
      $$invalidate(0, onlyThirdPartyProviders = $$props2.onlyThirdPartyProviders);
    if ("i18n" in $$props2)
      $$invalidate(10, i18n = $$props2.i18n);
    if ("providers" in $$props2)
      $$invalidate(1, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(11, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(12, queryParams = $$props2.queryParams);
    if ("appearance" in $$props2)
      $$invalidate(2, appearance = $$props2.appearance);
    if ("error" in $$props2)
      error = $$props2.error;
    if ("loading" in $$props2)
      $$invalidate(3, loading = $$props2.loading);
    if ("iconTitle" in $$props2)
      $$invalidate(6, iconTitle = $$props2.iconTitle);
    if ("verticalSocialLayout" in $$props2)
      $$invalidate(4, verticalSocialLayout = $$props2.verticalSocialLayout);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*socialLayout*/
    256) {
      $:
        $$invalidate(4, verticalSocialLayout = socialLayout === "vertical" ? true : false);
    }
  };
  return [
    onlyThirdPartyProviders,
    providers,
    appearance,
    loading,
    verticalSocialLayout,
    handleProviderSignIn,
    iconTitle,
    supabaseClient,
    socialLayout,
    redirectTo,
    i18n,
    providerScopes,
    queryParams,
    click_handler
  ];
}
var SocialAuth = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      supabaseClient: 7,
      socialLayout: 8,
      redirectTo: 9,
      onlyThirdPartyProviders: 0,
      i18n: 10,
      providers: 1,
      providerScopes: 11,
      queryParams: 12,
      appearance: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SocialAuth",
      options,
      id: create_fragment12.name
    });
  }
  get supabaseClient() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get socialLayout() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set socialLayout(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirectTo() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirectTo(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onlyThirdPartyProviders() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onlyThirdPartyProviders(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get i18n() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set i18n(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providers() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providers(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providerScopes() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providerScopes(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryParams() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryParams(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SocialAuth_default = SocialAuth;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/interfaces/UpdatePassword.svelte
var file12 = "node_modules/@supabase/auth-ui-svelte/dist/Auth/interfaces/UpdatePassword.svelte";
function add_css6(target) {
  append_styles(target, "svelte-nm5p4o", "form.svelte-nm5p4o{width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVXBkYXRlUGFzc3dvcmQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQThFQyxrQkFBSyxDQUNKLEtBQUssQ0FBRSxJQUNSIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlVwZGF0ZVBhc3N3b3JkLnN2ZWx0ZSJdfQ== */");
}
function create_default_slot_64(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[1]) == null ? void 0 : _a.update_password) == null ? void 0 : _b.password_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      2 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[1]) == null ? void 0 : _a2.update_password) == null ? void 0 : _b2.password_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_64.name,
    type: "slot",
    source: '(36:4) <Label for=\\"password\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_54(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[1]) == null ? void 0 : _a.update_password) == null ? void 0 : _b.button_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      2 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[1]) == null ? void 0 : _a2.update_password) == null ? void 0 : _b2.button_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_54.name,
    type: "slot",
    source: '(50:3) <Button type=\\"submit\\" color=\\"primary\\" {loading} {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_44(ctx) {
  var _a, _b;
  let div;
  let label;
  let t0;
  let input;
  let updating_value;
  let t1;
  let button;
  let current;
  label = new Label_default({
    props: {
      for: "password",
      appearance: (
        /*appearance*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_64] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function input_value_binding(value) {
    ctx[10](value);
  }
  let input_props = {
    id: "password",
    type: "password",
    name: "password",
    autofocus: true,
    placeholder: (
      /*i18n*/
      (_b = (_a = ctx[1]) == null ? void 0 : _a.update_password) == null ? void 0 : _b.password_label
    ),
    autocomplete: "password",
    appearance: (
      /*appearance*/
      ctx[2]
    )
  };
  if (
    /*password*/
    ctx[4] !== void 0
  ) {
    input_props.value = /*password*/
    ctx[4];
  }
  input = new Input_default({ props: input_props, $$inline: true });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  button = new Button_default({
    props: {
      type: "submit",
      color: "primary",
      loading: (
        /*loading*/
        ctx[7]
      ),
      appearance: (
        /*appearance*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_54] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(label.$$.fragment);
      t0 = space();
      create_component(input.$$.fragment);
      t1 = space();
      create_component(button.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(label.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      claim_component(input.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      claim_component(button.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file12, 34, 3, 1105);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(label, div, null);
      append_hydration_dev(div, t0);
      mount_component(input, div, null);
      insert_hydration_dev(target, t1, anchor);
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      const label_changes = {};
      if (dirty & /*appearance*/
      4)
        label_changes.appearance = /*appearance*/
        ctx2[2];
      if (dirty & /*$$scope, i18n*/
      4098) {
        label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      label.$set(label_changes);
      const input_changes = {};
      if (dirty & /*i18n*/
      2)
        input_changes.placeholder = /*i18n*/
        (_b2 = (_a2 = ctx2[1]) == null ? void 0 : _a2.update_password) == null ? void 0 : _b2.password_label;
      if (dirty & /*appearance*/
      4)
        input_changes.appearance = /*appearance*/
        ctx2[2];
      if (!updating_value && dirty & /*password*/
      16) {
        updating_value = true;
        input_changes.value = /*password*/
        ctx2[4];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
      const button_changes = {};
      if (dirty & /*loading*/
      128)
        button_changes.loading = /*loading*/
        ctx2[7];
      if (dirty & /*appearance*/
      4)
        button_changes.appearance = /*appearance*/
        ctx2[2];
      if (dirty & /*$$scope, i18n*/
      4098) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      transition_in(input.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label.$$.fragment, local);
      transition_out(input.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(label);
      destroy_component(input);
      if (detaching)
        detach_dev(t1);
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_44.name,
    type: "slot",
    source: '(34:2) <Container direction=\\"vertical\\" gap=\\"large\\" {appearance}>',
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let anchor;
  let current;
  anchor = new Anchor_default({
    props: {
      href: "#auth-magic-link",
      appearance: (
        /*appearance*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_34] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  anchor.$on(
    "click",
    /*click_handler*/
    ctx[11]
  );
  const block = {
    c: function create() {
      create_component(anchor.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchor.$$.fragment, nodes);
    },
    m: function mount(target, anchor$1) {
      mount_component(anchor, target, anchor$1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const anchor_changes = {};
      if (dirty & /*appearance*/
      4)
        anchor_changes.appearance = /*appearance*/
        ctx2[2];
      if (dirty & /*$$scope, i18n*/
      4098) {
        anchor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchor.$set(anchor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(55:2) {#if showLinks}",
    ctx
  });
  return block;
}
function create_default_slot_34(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[1]) == null ? void 0 : _a.sign_in) == null ? void 0 : _b.link_text) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      2 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[1]) == null ? void 0 : _a2.sign_in) == null ? void 0 : _b2.link_text) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_34.name,
    type: "slot",
    source: '(56:3) <Anchor     on:click={(e) => {      e.preventDefault();      authView = VIEWS.SIGN_IN;     }}     href=\\"#auth-magic-link\\"     {appearance}>',
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let message_1;
  let current;
  message_1 = new Message_default({
    props: {
      appearance: (
        /*appearance*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_25] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_1_changes = {};
      if (dirty & /*appearance*/
      4)
        message_1_changes.appearance = /*appearance*/
        ctx2[2];
      if (dirty & /*$$scope, message*/
      4128) {
        message_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      message_1.$set(message_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(message_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(65:2) {#if message}",
    ctx
  });
  return block;
}
function create_default_slot_25(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*message*/
        ctx[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*message*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*message*/
      32)
        set_data_dev(
          t,
          /*message*/
          ctx2[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_25.name,
    type: "slot",
    source: "(66:3) <Message {appearance}>",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let message_1;
  let current;
  message_1 = new Message_default({
    props: {
      color: "danger",
      appearance: (
        /*appearance*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_1_changes = {};
      if (dirty & /*appearance*/
      4)
        message_1_changes.appearance = /*appearance*/
        ctx2[2];
      if (dirty & /*$$scope, error*/
      4160) {
        message_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      message_1.$set(message_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(message_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(70:2) {#if error}",
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*error*/
        ctx[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*error*/
        ctx[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*error*/
      64)
        set_data_dev(
          t,
          /*error*/
          ctx2[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: '(71:3) <Message color=\\"danger\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let container;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  container = new Container_default({
    props: {
      direction: "vertical",
      gap: "large",
      appearance: (
        /*appearance*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_44] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block0 = (
    /*showLinks*/
    ctx[3] && create_if_block_26(ctx)
  );
  let if_block1 = (
    /*message*/
    ctx[5] && create_if_block_18(ctx)
  );
  let if_block2 = (
    /*error*/
    ctx[6] && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(container.$$.fragment, nodes);
      t0 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = {};
      if (dirty & /*appearance*/
      4)
        container_changes.appearance = /*appearance*/
        ctx2[2];
      if (dirty & /*$$scope, loading, appearance, i18n, password*/
      4246) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
      if (
        /*showLinks*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*showLinks*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_26(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*message*/
        ctx2[5]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*message*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_18(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*error*/
        ctx2[6]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*error*/
          64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block6(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: '(33:1) <Container direction=\\"vertical\\" gap=\\"large\\" {appearance}>',
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let form;
  let container;
  let current;
  let mounted;
  let dispose;
  container = new Container_default({
    props: {
      direction: "vertical",
      gap: "large",
      appearance: (
        /*appearance*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      form = element("form");
      create_component(container.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { id: true, method: true, class: true });
      var form_nodes = children(form);
      claim_component(container.$$.fragment, form_nodes);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(form, "id", "auth-update-password");
      attr_dev(form, "method", "post");
      attr_dev(form, "class", "svelte-nm5p4o");
      add_location(form, file12, 31, 0, 896);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      mount_component(container, form, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(form, "submit", prevent_default(
          /*handleSubmit*/
          ctx[8]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const container_changes = {};
      if (dirty & /*appearance*/
      4)
        container_changes.appearance = /*appearance*/
        ctx2[2];
      if (dirty & /*$$scope, appearance, error, message, authView, i18n, showLinks, loading, password*/
      4351) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      destroy_component(container);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UpdatePassword", slots, []);
  let { i18n } = $$props;
  let { supabaseClient } = $$props;
  let { authView } = $$props;
  let { appearance } = $$props;
  let { showLinks = false } = $$props;
  let password = "";
  let message = "";
  let error = "";
  let loading = false;
  async function handleSubmit() {
    var _a;
    $$invalidate(7, loading = true);
    $$invalidate(6, error = "");
    $$invalidate(5, message = "");
    const { data, error: resetPasswordError } = await supabaseClient.auth.updateUser({ password });
    if (resetPasswordError)
      $$invalidate(6, error = resetPasswordError.message);
    else
      $$invalidate(5, message = (_a = i18n.update_password) == null ? void 0 : _a.confirmation_text);
    $$invalidate(7, loading = false);
  }
  $$self.$$.on_mount.push(function() {
    if (i18n === void 0 && !("i18n" in $$props || $$self.$$.bound[$$self.$$.props["i18n"]])) {
      console.warn("<UpdatePassword> was created without expected prop 'i18n'");
    }
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<UpdatePassword> was created without expected prop 'supabaseClient'");
    }
    if (authView === void 0 && !("authView" in $$props || $$self.$$.bound[$$self.$$.props["authView"]])) {
      console.warn("<UpdatePassword> was created without expected prop 'authView'");
    }
    if (appearance === void 0 && !("appearance" in $$props || $$self.$$.bound[$$self.$$.props["appearance"]])) {
      console.warn("<UpdatePassword> was created without expected prop 'appearance'");
    }
  });
  const writable_props = ["i18n", "supabaseClient", "authView", "appearance", "showLinks"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UpdatePassword> was created with unknown prop '${key}'`);
  });
  function input_value_binding(value) {
    password = value;
    $$invalidate(4, password);
  }
  const click_handler = (e) => {
    e.preventDefault();
    $$invalidate(0, authView = VIEWS.SIGN_IN);
  };
  $$self.$$set = ($$props2) => {
    if ("i18n" in $$props2)
      $$invalidate(1, i18n = $$props2.i18n);
    if ("supabaseClient" in $$props2)
      $$invalidate(9, supabaseClient = $$props2.supabaseClient);
    if ("authView" in $$props2)
      $$invalidate(0, authView = $$props2.authView);
    if ("appearance" in $$props2)
      $$invalidate(2, appearance = $$props2.appearance);
    if ("showLinks" in $$props2)
      $$invalidate(3, showLinks = $$props2.showLinks);
  };
  $$self.$capture_state = () => ({
    Anchor: Anchor_default,
    Button: Button_default,
    Container: Container_default,
    Input: Input_default,
    Label: Label_default,
    Message: Message_default,
    VIEWS,
    i18n,
    supabaseClient,
    authView,
    appearance,
    showLinks,
    password,
    message,
    error,
    loading,
    handleSubmit
  });
  $$self.$inject_state = ($$props2) => {
    if ("i18n" in $$props2)
      $$invalidate(1, i18n = $$props2.i18n);
    if ("supabaseClient" in $$props2)
      $$invalidate(9, supabaseClient = $$props2.supabaseClient);
    if ("authView" in $$props2)
      $$invalidate(0, authView = $$props2.authView);
    if ("appearance" in $$props2)
      $$invalidate(2, appearance = $$props2.appearance);
    if ("showLinks" in $$props2)
      $$invalidate(3, showLinks = $$props2.showLinks);
    if ("password" in $$props2)
      $$invalidate(4, password = $$props2.password);
    if ("message" in $$props2)
      $$invalidate(5, message = $$props2.message);
    if ("error" in $$props2)
      $$invalidate(6, error = $$props2.error);
    if ("loading" in $$props2)
      $$invalidate(7, loading = $$props2.loading);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    authView,
    i18n,
    appearance,
    showLinks,
    password,
    message,
    error,
    loading,
    handleSubmit,
    supabaseClient,
    input_value_binding,
    click_handler
  ];
}
var UpdatePassword = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        i18n: 1,
        supabaseClient: 9,
        authView: 0,
        appearance: 2,
        showLinks: 3
      },
      add_css6
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UpdatePassword",
      options,
      id: create_fragment13.name
    });
  }
  get i18n() {
    throw new Error("<UpdatePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set i18n(value) {
    throw new Error("<UpdatePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get supabaseClient() {
    throw new Error("<UpdatePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<UpdatePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get authView() {
    throw new Error("<UpdatePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set authView(value) {
    throw new Error("<UpdatePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<UpdatePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<UpdatePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLinks() {
    throw new Error("<UpdatePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLinks(value) {
    throw new Error("<UpdatePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UpdatePassword_default = UpdatePassword;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/interfaces/VerifyOtp.svelte
var file13 = "node_modules/@supabase/auth-ui-svelte/dist/Auth/interfaces/VerifyOtp.svelte";
function add_css7(target) {
  append_styles(target, "svelte-nm5p4o", "form.svelte-nm5p4o{width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmVyaWZ5T3RwLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpSEMsa0JBQUssQ0FDSixLQUFLLENBQUUsSUFDUiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJWZXJpZnlPdHAuc3ZlbHRlIl19 */");
}
function create_else_block2(ctx) {
  var _a, _b;
  let div;
  let label;
  let t;
  let input;
  let updating_value;
  let current;
  label = new Label_default({
    props: {
      for: "email",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_72] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function input_value_binding_1(value) {
    ctx[14](value);
  }
  let input_props = {
    id: "email",
    type: "email",
    name: "email",
    autofocus: true,
    placeholder: (
      /*i18n*/
      (_b = (_a = ctx[4]) == null ? void 0 : _a.verify_otp) == null ? void 0 : _b.email_input_placeholder
    ),
    autocomplete: "email",
    appearance: (
      /*appearance*/
      ctx[6]
    )
  };
  if (
    /*email*/
    ctx[1] !== void 0
  ) {
    input_props.value = /*email*/
    ctx[1];
  }
  input = new Input_default({ props: input_props, $$inline: true });
  binding_callbacks.push(() => bind(input, "value", input_value_binding_1));
  const block = {
    c: function create() {
      div = element("div");
      create_component(label.$$.fragment);
      t = space();
      create_component(input.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(label.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      claim_component(input.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file13, 59, 3, 1599);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(label, div, null);
      append_hydration_dev(div, t);
      mount_component(input, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      const label_changes = {};
      if (dirty & /*appearance*/
      64)
        label_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      131088) {
        label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      label.$set(label_changes);
      const input_changes = {};
      if (dirty & /*i18n*/
      16)
        input_changes.placeholder = /*i18n*/
        (_b2 = (_a2 = ctx2[4]) == null ? void 0 : _a2.verify_otp) == null ? void 0 : _b2.email_input_placeholder;
      if (dirty & /*appearance*/
      64)
        input_changes.appearance = /*appearance*/
        ctx2[6];
      if (!updating_value && dirty & /*email*/
      2) {
        updating_value = true;
        input_changes.value = /*email*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label.$$.fragment, local);
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(label);
      destroy_component(input);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(59:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  var _a, _b;
  let div;
  let label;
  let t;
  let input;
  let updating_value;
  let current;
  label = new Label_default({
    props: {
      for: "phone",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_65] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function input_value_binding(value) {
    ctx[13](value);
  }
  let input_props = {
    id: "phone",
    type: "text",
    name: "phone",
    autofocus: true,
    placeholder: (
      /*i18n*/
      (_b = (_a = ctx[4]) == null ? void 0 : _a.verify_otp) == null ? void 0 : _b.phone_input_placeholder
    ),
    autocomplete: "phone",
    appearance: (
      /*appearance*/
      ctx[6]
    )
  };
  if (
    /*phone*/
    ctx[2] !== void 0
  ) {
    input_props.value = /*phone*/
    ctx[2];
  }
  input = new Input_default({ props: input_props, $$inline: true });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  const block = {
    c: function create() {
      div = element("div");
      create_component(label.$$.fragment);
      t = space();
      create_component(input.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(label.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      claim_component(input.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file13, 45, 3, 1275);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(label, div, null);
      append_hydration_dev(div, t);
      mount_component(input, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      const label_changes = {};
      if (dirty & /*appearance*/
      64)
        label_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      131088) {
        label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      label.$set(label_changes);
      const input_changes = {};
      if (dirty & /*i18n*/
      16)
        input_changes.placeholder = /*i18n*/
        (_b2 = (_a2 = ctx2[4]) == null ? void 0 : _a2.verify_otp) == null ? void 0 : _b2.phone_input_placeholder;
      if (dirty & /*appearance*/
      64)
        input_changes.appearance = /*appearance*/
        ctx2[6];
      if (!updating_value && dirty & /*phone*/
      4) {
        updating_value = true;
        input_changes.value = /*phone*/
        ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label.$$.fragment, local);
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(label);
      destroy_component(input);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(45:2) {#if ['sms', 'phone_change'].includes(otpType)}",
    ctx
  });
  return block;
}
function create_default_slot_72(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[4]) == null ? void 0 : _a.verify_otp) == null ? void 0 : _b.email_input_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      16 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[4]) == null ? void 0 : _a2.verify_otp) == null ? void 0 : _b2.email_input_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_72.name,
    type: "slot",
    source: '(61:4) <Label for=\\"email\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_65(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[4]) == null ? void 0 : _a.verify_otp) == null ? void 0 : _b.phone_input_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      16 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[4]) == null ? void 0 : _a2.verify_otp) == null ? void 0 : _b2.phone_input_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_65.name,
    type: "slot",
    source: '(47:4) <Label for=\\"phone\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_55(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[4]) == null ? void 0 : _a.verify_otp) == null ? void 0 : _b.token_input_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      16 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[4]) == null ? void 0 : _a2.verify_otp) == null ? void 0 : _b2.token_input_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_55.name,
    type: "slot",
    source: '(75:3) <Label for=\\"token\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot_45(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[4]) == null ? void 0 : _a.verify_otp) == null ? void 0 : _b.button_label) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      16 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[4]) == null ? void 0 : _a2.verify_otp) == null ? void 0 : _b2.button_label) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_45.name,
    type: "slot",
    source: '(86:2) <Button type=\\"submit\\" color=\\"primary\\" {loading} {appearance}>',
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let anchor;
  let current;
  anchor = new Anchor_default({
    props: {
      href: "#auth-sign-in",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_35] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  anchor.$on(
    "click",
    /*click_handler*/
    ctx[16]
  );
  const block = {
    c: function create() {
      create_component(anchor.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchor.$$.fragment, nodes);
    },
    m: function mount(target, anchor$1) {
      mount_component(anchor, target, anchor$1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const anchor_changes = {};
      if (dirty & /*appearance*/
      64)
        anchor_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      131088) {
        anchor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchor.$set(anchor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(90:2) {#if showLinks}",
    ctx
  });
  return block;
}
function create_default_slot_35(ctx) {
  var _a, _b;
  let t_value = (
    /*i18n*/
    ((_b = (_a = ctx[4]) == null ? void 0 : _a.sign_in) == null ? void 0 : _b.link_text) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*i18n*/
      16 && t_value !== (t_value = /*i18n*/
      ((_b2 = (_a2 = ctx2[4]) == null ? void 0 : _a2.sign_in) == null ? void 0 : _b2.link_text) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_35.name,
    type: "slot",
    source: '(91:3) <Anchor     on:click={(e) => {      e.preventDefault();      authView = VIEWS.SIGN_IN;     }}     href=\\"#auth-sign-in\\"     {appearance}>',
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let message_1;
  let current;
  message_1 = new Message_default({
    props: {
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_26] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_1_changes = {};
      if (dirty & /*appearance*/
      64)
        message_1_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, message*/
      131328) {
        message_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      message_1.$set(message_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(message_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(100:2) {#if message}",
    ctx
  });
  return block;
}
function create_default_slot_26(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*message*/
        ctx[8]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*message*/
        ctx[8]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*message*/
      256)
        set_data_dev(
          t,
          /*message*/
          ctx2[8]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_26.name,
    type: "slot",
    source: "(101:3) <Message {appearance}>",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let message_1;
  let current;
  message_1 = new Message_default({
    props: {
      color: "danger",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_1_changes = {};
      if (dirty & /*appearance*/
      64)
        message_1_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, error*/
      131584) {
        message_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      message_1.$set(message_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(message_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(105:2) {#if error}",
    ctx
  });
  return block;
}
function create_default_slot_16(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*error*/
        ctx[9]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*error*/
        ctx[9]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*error*/
      512)
        set_data_dev(
          t,
          /*error*/
          ctx2[9]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: '(106:3) <Message color=\\"danger\\" {appearance}>',
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  var _a, _b;
  let show_if;
  let current_block_type_index;
  let if_block0;
  let t0;
  let div;
  let label;
  let t1;
  let input;
  let updating_value;
  let t2;
  let button;
  let t3;
  let t4;
  let t5;
  let if_block3_anchor;
  let current;
  const if_block_creators = [create_if_block_33, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*otpType*/
    32)
      show_if = null;
    if (show_if == null)
      show_if = !!["sms", "phone_change"].includes(
        /*otpType*/
        ctx2[5]
      );
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  label = new Label_default({
    props: {
      for: "token",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_55] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function input_value_binding_2(value) {
    ctx[15](value);
  }
  let input_props = {
    id: "token",
    type: "text",
    name: "token",
    placeholder: (
      /*i18n*/
      (_b = (_a = ctx[4]) == null ? void 0 : _a.verify_otp) == null ? void 0 : _b.token_input_placeholder
    ),
    autocomplete: "token",
    appearance: (
      /*appearance*/
      ctx[6]
    )
  };
  if (
    /*token*/
    ctx[3] !== void 0
  ) {
    input_props.value = /*token*/
    ctx[3];
  }
  input = new Input_default({ props: input_props, $$inline: true });
  binding_callbacks.push(() => bind(input, "value", input_value_binding_2));
  button = new Button_default({
    props: {
      type: "submit",
      color: "primary",
      loading: (
        /*loading*/
        ctx[10]
      ),
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_45] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block1 = (
    /*showLinks*/
    ctx[7] && create_if_block_27(ctx)
  );
  let if_block2 = (
    /*message*/
    ctx[8] && create_if_block_19(ctx)
  );
  let if_block3 = (
    /*error*/
    ctx[9] && create_if_block7(ctx)
  );
  const block = {
    c: function create() {
      if_block0.c();
      t0 = space();
      div = element("div");
      create_component(label.$$.fragment);
      t1 = space();
      create_component(input.$$.fragment);
      t2 = space();
      create_component(button.$$.fragment);
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      if_block0.l(nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      claim_component(label.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      claim_component(input.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      t2 = claim_space(nodes);
      claim_component(button.$$.fragment, nodes);
      t3 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t4 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t5 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      if_block3_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      add_location(div, file13, 73, 2, 1921);
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      mount_component(label, div, null);
      append_hydration_dev(div, t1);
      mount_component(input, div, null);
      insert_hydration_dev(target, t2, anchor);
      mount_component(button, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t4, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t5, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, if_block3_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t0.parentNode, t0);
      }
      const label_changes = {};
      if (dirty & /*appearance*/
      64)
        label_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      131088) {
        label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      label.$set(label_changes);
      const input_changes = {};
      if (dirty & /*i18n*/
      16)
        input_changes.placeholder = /*i18n*/
        (_b2 = (_a2 = ctx2[4]) == null ? void 0 : _a2.verify_otp) == null ? void 0 : _b2.token_input_placeholder;
      if (dirty & /*appearance*/
      64)
        input_changes.appearance = /*appearance*/
        ctx2[6];
      if (!updating_value && dirty & /*token*/
      8) {
        updating_value = true;
        input_changes.value = /*token*/
        ctx2[3];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
      const button_changes = {};
      if (dirty & /*loading*/
      1024)
        button_changes.loading = /*loading*/
        ctx2[10];
      if (dirty & /*appearance*/
      64)
        button_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, i18n*/
      131088) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      if (
        /*showLinks*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*showLinks*/
          128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_27(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t4.parentNode, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*message*/
        ctx2[8]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*message*/
          256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_19(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t5.parentNode, t5);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*error*/
        ctx2[9]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*error*/
          512) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block7(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(label.$$.fragment, local);
      transition_in(input.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(label.$$.fragment, local);
      transition_out(input.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      destroy_component(label);
      destroy_component(input);
      if (detaching)
        detach_dev(t2);
      destroy_component(button, detaching);
      if (detaching)
        detach_dev(t3);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t4);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(t5);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach_dev(if_block3_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: '(44:1) <Container direction=\\"vertical\\" gap=\\"large\\" {appearance}>',
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let form;
  let container;
  let current;
  let mounted;
  let dispose;
  container = new Container_default({
    props: {
      direction: "vertical",
      gap: "large",
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      form = element("form");
      create_component(container.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { id: true, method: true, class: true });
      var form_nodes = children(form);
      claim_component(container.$$.fragment, form_nodes);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(form, "id", "auth-magic-link");
      attr_dev(form, "method", "post");
      attr_dev(form, "class", "svelte-nm5p4o");
      add_location(form, file13, 42, 0, 1081);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      mount_component(container, form, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(form, "submit", prevent_default(
          /*handleSubmit*/
          ctx[11]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const container_changes = {};
      if (dirty & /*appearance*/
      64)
        container_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*$$scope, appearance, error, message, authView, i18n, showLinks, loading, token, phone, otpType, email*/
      133119) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      destroy_component(container);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VerifyOtp", slots, []);
  let { i18n } = $$props;
  let { supabaseClient } = $$props;
  let { authView } = $$props;
  let { otpType = "email" } = $$props;
  let { appearance } = $$props;
  let { showLinks = false } = $$props;
  let { email = "" } = $$props;
  let { phone = "" } = $$props;
  let { token = "" } = $$props;
  let message = "";
  let error = "";
  let loading = false;
  async function handleSubmit() {
    $$invalidate(10, loading = true);
    $$invalidate(9, error = "");
    $$invalidate(8, message = "");
    let verifyOpts = { email, token, type: otpType };
    if (["sms", "phone_change"].includes(otpType)) {
      verifyOpts = { phone, token, type: otpType };
    }
    const { error: err } = await supabaseClient.auth.verifyOtp(verifyOpts);
    if (err)
      $$invalidate(9, error = err.message);
    $$invalidate(10, loading = false);
  }
  $$self.$$.on_mount.push(function() {
    if (i18n === void 0 && !("i18n" in $$props || $$self.$$.bound[$$self.$$.props["i18n"]])) {
      console.warn("<VerifyOtp> was created without expected prop 'i18n'");
    }
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<VerifyOtp> was created without expected prop 'supabaseClient'");
    }
    if (authView === void 0 && !("authView" in $$props || $$self.$$.bound[$$self.$$.props["authView"]])) {
      console.warn("<VerifyOtp> was created without expected prop 'authView'");
    }
    if (appearance === void 0 && !("appearance" in $$props || $$self.$$.bound[$$self.$$.props["appearance"]])) {
      console.warn("<VerifyOtp> was created without expected prop 'appearance'");
    }
  });
  const writable_props = [
    "i18n",
    "supabaseClient",
    "authView",
    "otpType",
    "appearance",
    "showLinks",
    "email",
    "phone",
    "token"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VerifyOtp> was created with unknown prop '${key}'`);
  });
  function input_value_binding(value) {
    phone = value;
    $$invalidate(2, phone);
  }
  function input_value_binding_1(value) {
    email = value;
    $$invalidate(1, email);
  }
  function input_value_binding_2(value) {
    token = value;
    $$invalidate(3, token);
  }
  const click_handler = (e) => {
    e.preventDefault();
    $$invalidate(0, authView = VIEWS.SIGN_IN);
  };
  $$self.$$set = ($$props2) => {
    if ("i18n" in $$props2)
      $$invalidate(4, i18n = $$props2.i18n);
    if ("supabaseClient" in $$props2)
      $$invalidate(12, supabaseClient = $$props2.supabaseClient);
    if ("authView" in $$props2)
      $$invalidate(0, authView = $$props2.authView);
    if ("otpType" in $$props2)
      $$invalidate(5, otpType = $$props2.otpType);
    if ("appearance" in $$props2)
      $$invalidate(6, appearance = $$props2.appearance);
    if ("showLinks" in $$props2)
      $$invalidate(7, showLinks = $$props2.showLinks);
    if ("email" in $$props2)
      $$invalidate(1, email = $$props2.email);
    if ("phone" in $$props2)
      $$invalidate(2, phone = $$props2.phone);
    if ("token" in $$props2)
      $$invalidate(3, token = $$props2.token);
  };
  $$self.$capture_state = () => ({
    Anchor: Anchor_default,
    Button: Button_default,
    Container: Container_default,
    Input: Input_default,
    Label: Label_default,
    Message: Message_default,
    VIEWS,
    i18n,
    supabaseClient,
    authView,
    otpType,
    appearance,
    showLinks,
    email,
    phone,
    token,
    message,
    error,
    loading,
    handleSubmit
  });
  $$self.$inject_state = ($$props2) => {
    if ("i18n" in $$props2)
      $$invalidate(4, i18n = $$props2.i18n);
    if ("supabaseClient" in $$props2)
      $$invalidate(12, supabaseClient = $$props2.supabaseClient);
    if ("authView" in $$props2)
      $$invalidate(0, authView = $$props2.authView);
    if ("otpType" in $$props2)
      $$invalidate(5, otpType = $$props2.otpType);
    if ("appearance" in $$props2)
      $$invalidate(6, appearance = $$props2.appearance);
    if ("showLinks" in $$props2)
      $$invalidate(7, showLinks = $$props2.showLinks);
    if ("email" in $$props2)
      $$invalidate(1, email = $$props2.email);
    if ("phone" in $$props2)
      $$invalidate(2, phone = $$props2.phone);
    if ("token" in $$props2)
      $$invalidate(3, token = $$props2.token);
    if ("message" in $$props2)
      $$invalidate(8, message = $$props2.message);
    if ("error" in $$props2)
      $$invalidate(9, error = $$props2.error);
    if ("loading" in $$props2)
      $$invalidate(10, loading = $$props2.loading);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    authView,
    email,
    phone,
    token,
    i18n,
    otpType,
    appearance,
    showLinks,
    message,
    error,
    loading,
    handleSubmit,
    supabaseClient,
    input_value_binding,
    input_value_binding_1,
    input_value_binding_2,
    click_handler
  ];
}
var VerifyOtp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance14,
      create_fragment14,
      safe_not_equal,
      {
        i18n: 4,
        supabaseClient: 12,
        authView: 0,
        otpType: 5,
        appearance: 6,
        showLinks: 7,
        email: 1,
        phone: 2,
        token: 3
      },
      add_css7
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VerifyOtp",
      options,
      id: create_fragment14.name
    });
  }
  get i18n() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set i18n(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get supabaseClient() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get authView() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set authView(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get otpType() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set otpType(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLinks() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLinks(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get email() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set email(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get phone() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set phone(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get token() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set token(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VerifyOtp_default = VerifyOtp;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/Auth.svelte
var file14 = "node_modules/@supabase/auth-ui-svelte/dist/Auth/Auth.svelte";
function create_if_block_82(ctx) {
  let socialauth;
  let current;
  socialauth = new SocialAuth_default({
    props: {
      appearance: (
        /*appearance*/
        ctx[10]
      ),
      supabaseClient: (
        /*supabaseClient*/
        ctx[1]
      ),
      providers: (
        /*providers*/
        ctx[3]
      ),
      providerScopes: (
        /*providerScopes*/
        ctx[4]
      ),
      queryParams: (
        /*queryParams*/
        ctx[5]
      ),
      socialLayout: (
        /*socialLayout*/
        ctx[2]
      ),
      redirectTo: (
        /*redirectTo*/
        ctx[6]
      ),
      onlyThirdPartyProviders: (
        /*onlyThirdPartyProviders*/
        ctx[7]
      ),
      i18n: (
        /*i18n*/
        ctx[16]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(socialauth.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(socialauth.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(socialauth, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const socialauth_changes = {};
      if (dirty & /*appearance*/
      1024)
        socialauth_changes.appearance = /*appearance*/
        ctx2[10];
      if (dirty & /*supabaseClient*/
      2)
        socialauth_changes.supabaseClient = /*supabaseClient*/
        ctx2[1];
      if (dirty & /*providers*/
      8)
        socialauth_changes.providers = /*providers*/
        ctx2[3];
      if (dirty & /*providerScopes*/
      16)
        socialauth_changes.providerScopes = /*providerScopes*/
        ctx2[4];
      if (dirty & /*queryParams*/
      32)
        socialauth_changes.queryParams = /*queryParams*/
        ctx2[5];
      if (dirty & /*socialLayout*/
      4)
        socialauth_changes.socialLayout = /*socialLayout*/
        ctx2[2];
      if (dirty & /*redirectTo*/
      64)
        socialauth_changes.redirectTo = /*redirectTo*/
        ctx2[6];
      if (dirty & /*onlyThirdPartyProviders*/
      128)
        socialauth_changes.onlyThirdPartyProviders = /*onlyThirdPartyProviders*/
        ctx2[7];
      if (dirty & /*i18n*/
      65536)
        socialauth_changes.i18n = /*i18n*/
        ctx2[16];
      socialauth.$set(socialauth_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(socialauth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(socialauth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(socialauth, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_82.name,
    type: "if",
    source: "(52:1) {#if SignView}",
    ctx
  });
  return block;
}
function create_if_block_62(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*onlyThirdPartyProviders*/
  ctx[7] && create_if_block_72(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*onlyThirdPartyProviders*/
      ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*onlyThirdPartyProviders*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_72(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_62.name,
    type: "if",
    source: "(65:1) {#if view === VIEWS.SIGN_IN}",
    ctx
  });
  return block;
}
function create_if_block_72(ctx) {
  let emailauth;
  let updating_authView;
  let current;
  function emailauth_authView_binding(value) {
    ctx[19](value);
  }
  let emailauth_props = {
    appearance: (
      /*appearance*/
      ctx[10]
    ),
    supabaseClient: (
      /*supabaseClient*/
      ctx[1]
    ),
    redirectTo: (
      /*redirectTo*/
      ctx[6]
    ),
    magicLink: (
      /*magicLink*/
      ctx[8]
    ),
    showLinks: (
      /*showLinks*/
      ctx[9]
    ),
    i18n: (
      /*i18n*/
      ctx[16]
    ),
    additionalData: (
      /*additionalData*/
      ctx[13]
    )
  };
  if (
    /*view*/
    ctx[0] !== void 0
  ) {
    emailauth_props.authView = /*view*/
    ctx[0];
  }
  emailauth = new EmailAuth_default({ props: emailauth_props, $$inline: true });
  binding_callbacks.push(() => bind(emailauth, "authView", emailauth_authView_binding));
  const block = {
    c: function create() {
      create_component(emailauth.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(emailauth.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(emailauth, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const emailauth_changes = {};
      if (dirty & /*appearance*/
      1024)
        emailauth_changes.appearance = /*appearance*/
        ctx2[10];
      if (dirty & /*supabaseClient*/
      2)
        emailauth_changes.supabaseClient = /*supabaseClient*/
        ctx2[1];
      if (dirty & /*redirectTo*/
      64)
        emailauth_changes.redirectTo = /*redirectTo*/
        ctx2[6];
      if (dirty & /*magicLink*/
      256)
        emailauth_changes.magicLink = /*magicLink*/
        ctx2[8];
      if (dirty & /*showLinks*/
      512)
        emailauth_changes.showLinks = /*showLinks*/
        ctx2[9];
      if (dirty & /*i18n*/
      65536)
        emailauth_changes.i18n = /*i18n*/
        ctx2[16];
      if (dirty & /*additionalData*/
      8192)
        emailauth_changes.additionalData = /*additionalData*/
        ctx2[13];
      if (!updating_authView && dirty & /*view*/
      1) {
        updating_authView = true;
        emailauth_changes.authView = /*view*/
        ctx2[0];
        add_flush_callback(() => updating_authView = false);
      }
      emailauth.$set(emailauth_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(emailauth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(emailauth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(emailauth, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_72.name,
    type: "if",
    source: "(66:2) {#if !onlyThirdPartyProviders}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*onlyThirdPartyProviders*/
  ctx[7] && create_if_block_52(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*onlyThirdPartyProviders*/
      ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*onlyThirdPartyProviders*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_52(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(79:1) {#if view === VIEWS.SIGN_UP}",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let emailauth;
  let updating_authView;
  let current;
  function emailauth_authView_binding_1(value) {
    ctx[20](value);
  }
  let emailauth_props = {
    appearance: (
      /*appearance*/
      ctx[10]
    ),
    supabaseClient: (
      /*supabaseClient*/
      ctx[1]
    ),
    redirectTo: (
      /*redirectTo*/
      ctx[6]
    ),
    magicLink: (
      /*magicLink*/
      ctx[8]
    ),
    showLinks: (
      /*showLinks*/
      ctx[9]
    ),
    additionalData: (
      /*additionalData*/
      ctx[13]
    ),
    i18n: (
      /*i18n*/
      ctx[16]
    ),
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  if (
    /*view*/
    ctx[0] !== void 0
  ) {
    emailauth_props.authView = /*view*/
    ctx[0];
  }
  emailauth = new EmailAuth_default({ props: emailauth_props, $$inline: true });
  binding_callbacks.push(() => bind(emailauth, "authView", emailauth_authView_binding_1));
  const block = {
    c: function create() {
      create_component(emailauth.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(emailauth.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(emailauth, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const emailauth_changes = {};
      if (dirty & /*appearance*/
      1024)
        emailauth_changes.appearance = /*appearance*/
        ctx2[10];
      if (dirty & /*supabaseClient*/
      2)
        emailauth_changes.supabaseClient = /*supabaseClient*/
        ctx2[1];
      if (dirty & /*redirectTo*/
      64)
        emailauth_changes.redirectTo = /*redirectTo*/
        ctx2[6];
      if (dirty & /*magicLink*/
      256)
        emailauth_changes.magicLink = /*magicLink*/
        ctx2[8];
      if (dirty & /*showLinks*/
      512)
        emailauth_changes.showLinks = /*showLinks*/
        ctx2[9];
      if (dirty & /*additionalData*/
      8192)
        emailauth_changes.additionalData = /*additionalData*/
        ctx2[13];
      if (dirty & /*i18n*/
      65536)
        emailauth_changes.i18n = /*i18n*/
        ctx2[16];
      if (dirty & /*$$scope*/
      33554432) {
        emailauth_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_authView && dirty & /*view*/
      1) {
        updating_authView = true;
        emailauth_changes.authView = /*view*/
        ctx2[0];
        add_flush_callback(() => updating_authView = false);
      }
      emailauth.$set(emailauth_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(emailauth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(emailauth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(emailauth, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(80:2) {#if !onlyThirdPartyProviders}",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(81:3) <EmailAuth     {appearance}     {supabaseClient}     bind:authView={view}     {redirectTo}     {magicLink}     {showLinks}     {additionalData}     {i18n}>",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let forgottenpassword;
  let updating_authView;
  let current;
  function forgottenpassword_authView_binding(value) {
    ctx[21](value);
  }
  let forgottenpassword_props = {
    i18n: (
      /*i18n*/
      ctx[16]
    ),
    supabaseClient: (
      /*supabaseClient*/
      ctx[1]
    ),
    showLinks: (
      /*showLinks*/
      ctx[9]
    ),
    appearance: (
      /*appearance*/
      ctx[10]
    )
  };
  if (
    /*view*/
    ctx[0] !== void 0
  ) {
    forgottenpassword_props.authView = /*view*/
    ctx[0];
  }
  forgottenpassword = new ForgottenPassword_default({
    props: forgottenpassword_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(forgottenpassword, "authView", forgottenpassword_authView_binding));
  const block = {
    c: function create() {
      create_component(forgottenpassword.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(forgottenpassword.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(forgottenpassword, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const forgottenpassword_changes = {};
      if (dirty & /*i18n*/
      65536)
        forgottenpassword_changes.i18n = /*i18n*/
        ctx2[16];
      if (dirty & /*supabaseClient*/
      2)
        forgottenpassword_changes.supabaseClient = /*supabaseClient*/
        ctx2[1];
      if (dirty & /*showLinks*/
      512)
        forgottenpassword_changes.showLinks = /*showLinks*/
        ctx2[9];
      if (dirty & /*appearance*/
      1024)
        forgottenpassword_changes.appearance = /*appearance*/
        ctx2[10];
      if (!updating_authView && dirty & /*view*/
      1) {
        updating_authView = true;
        forgottenpassword_changes.authView = /*view*/
        ctx2[0];
        add_flush_callback(() => updating_authView = false);
      }
      forgottenpassword.$set(forgottenpassword_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(forgottenpassword.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(forgottenpassword.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(forgottenpassword, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(93:1) {#if view === VIEWS.FORGOTTEN_PASSWORD}",
    ctx
  });
  return block;
}
function create_if_block_28(ctx) {
  let magiclink;
  let updating_authView;
  let current;
  function magiclink_authView_binding(value) {
    ctx[22](value);
  }
  let magiclink_props = {
    i18n: (
      /*i18n*/
      ctx[16]
    ),
    supabaseClient: (
      /*supabaseClient*/
      ctx[1]
    ),
    appearance: (
      /*appearance*/
      ctx[10]
    ),
    redirectTo: (
      /*redirectTo*/
      ctx[6]
    ),
    showLinks: (
      /*showLinks*/
      ctx[9]
    )
  };
  if (
    /*view*/
    ctx[0] !== void 0
  ) {
    magiclink_props.authView = /*view*/
    ctx[0];
  }
  magiclink = new MagicLink_default({ props: magiclink_props, $$inline: true });
  binding_callbacks.push(() => bind(magiclink, "authView", magiclink_authView_binding));
  const block = {
    c: function create() {
      create_component(magiclink.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(magiclink.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(magiclink, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const magiclink_changes = {};
      if (dirty & /*i18n*/
      65536)
        magiclink_changes.i18n = /*i18n*/
        ctx2[16];
      if (dirty & /*supabaseClient*/
      2)
        magiclink_changes.supabaseClient = /*supabaseClient*/
        ctx2[1];
      if (dirty & /*appearance*/
      1024)
        magiclink_changes.appearance = /*appearance*/
        ctx2[10];
      if (dirty & /*redirectTo*/
      64)
        magiclink_changes.redirectTo = /*redirectTo*/
        ctx2[6];
      if (dirty & /*showLinks*/
      512)
        magiclink_changes.showLinks = /*showLinks*/
        ctx2[9];
      if (!updating_authView && dirty & /*view*/
      1) {
        updating_authView = true;
        magiclink_changes.authView = /*view*/
        ctx2[0];
        add_flush_callback(() => updating_authView = false);
      }
      magiclink.$set(magiclink_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(magiclink.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(magiclink.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(magiclink, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(96:1) {#if view === VIEWS.MAGIC_LINK}",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let updatepassword;
  let updating_authView;
  let current;
  function updatepassword_authView_binding(value) {
    ctx[23](value);
  }
  let updatepassword_props = {
    i18n: (
      /*i18n*/
      ctx[16]
    ),
    supabaseClient: (
      /*supabaseClient*/
      ctx[1]
    ),
    appearance: (
      /*appearance*/
      ctx[10]
    ),
    showLinks: (
      /*showLinks*/
      ctx[9]
    )
  };
  if (
    /*view*/
    ctx[0] !== void 0
  ) {
    updatepassword_props.authView = /*view*/
    ctx[0];
  }
  updatepassword = new UpdatePassword_default({
    props: updatepassword_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(updatepassword, "authView", updatepassword_authView_binding));
  const block = {
    c: function create() {
      create_component(updatepassword.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(updatepassword.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(updatepassword, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const updatepassword_changes = {};
      if (dirty & /*i18n*/
      65536)
        updatepassword_changes.i18n = /*i18n*/
        ctx2[16];
      if (dirty & /*supabaseClient*/
      2)
        updatepassword_changes.supabaseClient = /*supabaseClient*/
        ctx2[1];
      if (dirty & /*appearance*/
      1024)
        updatepassword_changes.appearance = /*appearance*/
        ctx2[10];
      if (dirty & /*showLinks*/
      512)
        updatepassword_changes.showLinks = /*showLinks*/
        ctx2[9];
      if (!updating_authView && dirty & /*view*/
      1) {
        updating_authView = true;
        updatepassword_changes.authView = /*view*/
        ctx2[0];
        add_flush_callback(() => updating_authView = false);
      }
      updatepassword.$set(updatepassword_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(updatepassword.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(updatepassword.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(updatepassword, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(99:1) {#if view === VIEWS.UPDATE_PASSWORD}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let verifyotp;
  let updating_authView;
  let current;
  function verifyotp_authView_binding(value) {
    ctx[24](value);
  }
  let verifyotp_props = {
    i18n: (
      /*i18n*/
      ctx[16]
    ),
    supabaseClient: (
      /*supabaseClient*/
      ctx[1]
    ),
    appearance: (
      /*appearance*/
      ctx[10]
    ),
    showLinks: (
      /*showLinks*/
      ctx[9]
    ),
    otpType: (
      /*otpType*/
      ctx[12]
    )
  };
  if (
    /*view*/
    ctx[0] !== void 0
  ) {
    verifyotp_props.authView = /*view*/
    ctx[0];
  }
  verifyotp = new VerifyOtp_default({ props: verifyotp_props, $$inline: true });
  binding_callbacks.push(() => bind(verifyotp, "authView", verifyotp_authView_binding));
  const block = {
    c: function create() {
      create_component(verifyotp.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(verifyotp.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(verifyotp, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const verifyotp_changes = {};
      if (dirty & /*i18n*/
      65536)
        verifyotp_changes.i18n = /*i18n*/
        ctx2[16];
      if (dirty & /*supabaseClient*/
      2)
        verifyotp_changes.supabaseClient = /*supabaseClient*/
        ctx2[1];
      if (dirty & /*appearance*/
      1024)
        verifyotp_changes.appearance = /*appearance*/
        ctx2[10];
      if (dirty & /*showLinks*/
      512)
        verifyotp_changes.showLinks = /*showLinks*/
        ctx2[9];
      if (dirty & /*otpType*/
      4096)
        verifyotp_changes.otpType = /*otpType*/
        ctx2[12];
      if (!updating_authView && dirty & /*view*/
      1) {
        updating_authView = true;
        verifyotp_changes.authView = /*view*/
        ctx2[0];
        add_flush_callback(() => updating_authView = false);
      }
      verifyotp.$set(verifyotp_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(verifyotp.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(verifyotp.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(verifyotp, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(102:1) {#if view === VIEWS.VERIFY_OTP}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let div_class_value;
  let current;
  let if_block0 = (
    /*SignView*/
    ctx[14] && create_if_block_82(ctx)
  );
  let if_block1 = (
    /*view*/
    ctx[0] === VIEWS.SIGN_IN && create_if_block_62(ctx)
  );
  let if_block2 = (
    /*view*/
    ctx[0] === VIEWS.SIGN_UP && create_if_block_43(ctx)
  );
  let if_block3 = (
    /*view*/
    ctx[0] === VIEWS.FORGOTTEN_PASSWORD && create_if_block_34(ctx)
  );
  let if_block4 = (
    /*view*/
    ctx[0] === VIEWS.MAGIC_LINK && create_if_block_28(ctx)
  );
  let if_block5 = (
    /*view*/
    ctx[0] === VIEWS.UPDATE_PASSWORD && create_if_block_110(ctx)
  );
  let if_block6 = (
    /*view*/
    ctx[0] === VIEWS.VERIFY_OTP && create_if_block8(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      t5 = space();
      if (if_block6)
        if_block6.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block3)
        if_block3.l(div_nodes);
      t3 = claim_space(div_nodes);
      if (if_block4)
        if_block4.l(div_nodes);
      t4 = claim_space(div_nodes);
      if (if_block5)
        if_block5.l(div_nodes);
      t5 = claim_space(div_nodes);
      if (if_block6)
        if_block6.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*theme*/
      ctx[11] !== "default" ? (
        /*themeVariables*/
        ctx[15]
      ) : "");
      add_location(div, file14, 50, 0, 1836);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append_hydration_dev(div, t2);
      if (if_block3)
        if_block3.m(div, null);
      append_hydration_dev(div, t3);
      if (if_block4)
        if_block4.m(div, null);
      append_hydration_dev(div, t4);
      if (if_block5)
        if_block5.m(div, null);
      append_hydration_dev(div, t5);
      if (if_block6)
        if_block6.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*SignView*/
        ctx2[14]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*SignView*/
          16384) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_82(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*view*/
        ctx2[0] === VIEWS.SIGN_IN
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*view*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_62(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*view*/
        ctx2[0] === VIEWS.SIGN_UP
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*view*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_43(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*view*/
        ctx2[0] === VIEWS.FORGOTTEN_PASSWORD
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*view*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_34(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*view*/
        ctx2[0] === VIEWS.MAGIC_LINK
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*view*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_28(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*view*/
        ctx2[0] === VIEWS.UPDATE_PASSWORD
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*view*/
          1) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_110(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div, t5);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*view*/
        ctx2[0] === VIEWS.VERIFY_OTP
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty & /*view*/
          1) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block8(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div, null);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*theme, themeVariables*/
      34816 && div_class_value !== (div_class_value = /*theme*/
      ctx2[11] !== "default" ? (
        /*themeVariables*/
        ctx2[15]
      ) : "")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let i18n;
  let themeVariables;
  let SignView;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Auth", slots, ["default"]);
  let { supabaseClient } = $$props;
  let { socialLayout = "vertical" } = $$props;
  let { providers = [] } = $$props;
  let { providerScopes = void 0 } = $$props;
  let { queryParams = void 0 } = $$props;
  let { view = "sign_in" } = $$props;
  let { redirectTo = void 0 } = $$props;
  let { onlyThirdPartyProviders = false } = $$props;
  let { magicLink = false } = $$props;
  let { showLinks = true } = $$props;
  let { appearance = {} } = $$props;
  let { theme = "default" } = $$props;
  let { localization = {} } = $$props;
  let { otpType = "email" } = $$props;
  let { additionalData } = $$props;
  onMount(() => {
    const { data: authListener } = supabaseClient.auth.onAuthStateChange((event) => {
      if (event === "PASSWORD_RECOVERY") {
        $$invalidate(0, view = "update_password");
      } else if (event === "USER_UPDATED") {
        $$invalidate(0, view = "sign_in");
      }
    });
    () => authListener.subscription.unsubscribe();
  });
  $$self.$$.on_mount.push(function() {
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<Auth> was created without expected prop 'supabaseClient'");
    }
    if (additionalData === void 0 && !("additionalData" in $$props || $$self.$$.bound[$$self.$$.props["additionalData"]])) {
      console.warn("<Auth> was created without expected prop 'additionalData'");
    }
  });
  const writable_props = [
    "supabaseClient",
    "socialLayout",
    "providers",
    "providerScopes",
    "queryParams",
    "view",
    "redirectTo",
    "onlyThirdPartyProviders",
    "magicLink",
    "showLinks",
    "appearance",
    "theme",
    "localization",
    "otpType",
    "additionalData"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Auth> was created with unknown prop '${key}'`);
  });
  function emailauth_authView_binding(value) {
    view = value;
    $$invalidate(0, view);
  }
  function emailauth_authView_binding_1(value) {
    view = value;
    $$invalidate(0, view);
  }
  function forgottenpassword_authView_binding(value) {
    view = value;
    $$invalidate(0, view);
  }
  function magiclink_authView_binding(value) {
    view = value;
    $$invalidate(0, view);
  }
  function updatepassword_authView_binding(value) {
    view = value;
    $$invalidate(0, view);
  }
  function verifyotp_authView_binding(value) {
    view = value;
    $$invalidate(0, view);
  }
  $$self.$$set = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(1, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(2, socialLayout = $$props2.socialLayout);
    if ("providers" in $$props2)
      $$invalidate(3, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(4, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(5, queryParams = $$props2.queryParams);
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
    if ("redirectTo" in $$props2)
      $$invalidate(6, redirectTo = $$props2.redirectTo);
    if ("onlyThirdPartyProviders" in $$props2)
      $$invalidate(7, onlyThirdPartyProviders = $$props2.onlyThirdPartyProviders);
    if ("magicLink" in $$props2)
      $$invalidate(8, magicLink = $$props2.magicLink);
    if ("showLinks" in $$props2)
      $$invalidate(9, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(10, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(11, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(17, localization = $$props2.localization);
    if ("otpType" in $$props2)
      $$invalidate(12, otpType = $$props2.otpType);
    if ("additionalData" in $$props2)
      $$invalidate(13, additionalData = $$props2.additionalData);
    if ("$$scope" in $$props2)
      $$invalidate(25, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createStitches: X,
    createTheme: q,
    merge,
    VIEWS,
    en: en_default,
    EmailAuth: EmailAuth_default,
    ForgottenPassword: ForgottenPassword_default,
    MagicLink: MagicLink_default,
    SocialAuth: SocialAuth_default,
    UpdatePassword: UpdatePassword_default,
    VerifyOtp: VerifyOtp_default,
    onMount,
    supabaseClient,
    socialLayout,
    providers,
    providerScopes,
    queryParams,
    view,
    redirectTo,
    onlyThirdPartyProviders,
    magicLink,
    showLinks,
    appearance,
    theme,
    localization,
    otpType,
    additionalData,
    SignView,
    themeVariables,
    i18n
  });
  $$self.$inject_state = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(1, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(2, socialLayout = $$props2.socialLayout);
    if ("providers" in $$props2)
      $$invalidate(3, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(4, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(5, queryParams = $$props2.queryParams);
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
    if ("redirectTo" in $$props2)
      $$invalidate(6, redirectTo = $$props2.redirectTo);
    if ("onlyThirdPartyProviders" in $$props2)
      $$invalidate(7, onlyThirdPartyProviders = $$props2.onlyThirdPartyProviders);
    if ("magicLink" in $$props2)
      $$invalidate(8, magicLink = $$props2.magicLink);
    if ("showLinks" in $$props2)
      $$invalidate(9, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(10, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(11, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(17, localization = $$props2.localization);
    if ("otpType" in $$props2)
      $$invalidate(12, otpType = $$props2.otpType);
    if ("additionalData" in $$props2)
      $$invalidate(13, additionalData = $$props2.additionalData);
    if ("SignView" in $$props2)
      $$invalidate(14, SignView = $$props2.SignView);
    if ("themeVariables" in $$props2)
      $$invalidate(15, themeVariables = $$props2.themeVariables);
    if ("i18n" in $$props2)
      $$invalidate(16, i18n = $$props2.i18n);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b, _c, _d;
    if ($$self.$$.dirty & /*localization*/
    131072) {
      $:
        $$invalidate(16, i18n = merge(en_default, localization.variables ?? {}));
    }
    if ($$self.$$.dirty & /*appearance*/
    1024) {
      $:
        X({
          theme: merge(((_a = appearance == null ? void 0 : appearance.theme) == null ? void 0 : _a.default) ?? {}, ((_b = appearance == null ? void 0 : appearance.variables) == null ? void 0 : _b.default) ?? {})
        });
    }
    if ($$self.$$.dirty & /*appearance, theme*/
    3072) {
      $:
        $$invalidate(15, themeVariables = q(merge(
          // @ts-ignore
          (_c = appearance == null ? void 0 : appearance.theme) == null ? void 0 : _c[theme],
          ((_d = appearance == null ? void 0 : appearance.variables) == null ? void 0 : _d[theme]) ?? {}
        )));
    }
    if ($$self.$$.dirty & /*view*/
    1) {
      $:
        $$invalidate(14, SignView = view === "sign_in" || view === "sign_up" || view === "magic_link");
    }
  };
  return [
    view,
    supabaseClient,
    socialLayout,
    providers,
    providerScopes,
    queryParams,
    redirectTo,
    onlyThirdPartyProviders,
    magicLink,
    showLinks,
    appearance,
    theme,
    otpType,
    additionalData,
    SignView,
    themeVariables,
    i18n,
    localization,
    slots,
    emailauth_authView_binding,
    emailauth_authView_binding_1,
    forgottenpassword_authView_binding,
    magiclink_authView_binding,
    updatepassword_authView_binding,
    verifyotp_authView_binding,
    $$scope
  ];
}
var Auth = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {
      supabaseClient: 1,
      socialLayout: 2,
      providers: 3,
      providerScopes: 4,
      queryParams: 5,
      view: 0,
      redirectTo: 6,
      onlyThirdPartyProviders: 7,
      magicLink: 8,
      showLinks: 9,
      appearance: 10,
      theme: 11,
      localization: 17,
      otpType: 12,
      additionalData: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Auth",
      options,
      id: create_fragment15.name
    });
  }
  get supabaseClient() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get socialLayout() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set socialLayout(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providers() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providers(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providerScopes() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providerScopes(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryParams() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryParams(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get view() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set view(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirectTo() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirectTo(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onlyThirdPartyProviders() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onlyThirdPartyProviders(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get magicLink() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set magicLink(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLinks() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLinks(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get localization() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set localization(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get otpType() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set otpType(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get additionalData() {
    throw new Error("<Auth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set additionalData(value) {
    throw new Error("<Auth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Auth_default = Auth;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/ui/SignUp.svelte
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: '(16:0) <Auth  view=\\"sign_up\\"  onlyThirdPartyProviders={false}  {supabaseClient}  {showLinks}  {redirectTo}  {socialLayout}  {providers}  {providerScopes}  {queryParams}  {magicLink}  {appearance}  {theme}  {localization}  {additionalData} >',
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let auth;
  let current;
  auth = new Auth_default({
    props: {
      view: "sign_up",
      onlyThirdPartyProviders: false,
      supabaseClient: (
        /*supabaseClient*/
        ctx[0]
      ),
      showLinks: (
        /*showLinks*/
        ctx[7]
      ),
      redirectTo: (
        /*redirectTo*/
        ctx[5]
      ),
      socialLayout: (
        /*socialLayout*/
        ctx[1]
      ),
      providers: (
        /*providers*/
        ctx[2]
      ),
      providerScopes: (
        /*providerScopes*/
        ctx[3]
      ),
      queryParams: (
        /*queryParams*/
        ctx[4]
      ),
      magicLink: (
        /*magicLink*/
        ctx[6]
      ),
      appearance: (
        /*appearance*/
        ctx[8]
      ),
      theme: (
        /*theme*/
        ctx[9]
      ),
      localization: (
        /*localization*/
        ctx[10]
      ),
      additionalData: (
        /*additionalData*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(auth.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(auth.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(auth, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const auth_changes = {};
      if (dirty & /*supabaseClient*/
      1)
        auth_changes.supabaseClient = /*supabaseClient*/
        ctx2[0];
      if (dirty & /*showLinks*/
      128)
        auth_changes.showLinks = /*showLinks*/
        ctx2[7];
      if (dirty & /*redirectTo*/
      32)
        auth_changes.redirectTo = /*redirectTo*/
        ctx2[5];
      if (dirty & /*socialLayout*/
      2)
        auth_changes.socialLayout = /*socialLayout*/
        ctx2[1];
      if (dirty & /*providers*/
      4)
        auth_changes.providers = /*providers*/
        ctx2[2];
      if (dirty & /*providerScopes*/
      8)
        auth_changes.providerScopes = /*providerScopes*/
        ctx2[3];
      if (dirty & /*queryParams*/
      16)
        auth_changes.queryParams = /*queryParams*/
        ctx2[4];
      if (dirty & /*magicLink*/
      64)
        auth_changes.magicLink = /*magicLink*/
        ctx2[6];
      if (dirty & /*appearance*/
      256)
        auth_changes.appearance = /*appearance*/
        ctx2[8];
      if (dirty & /*theme*/
      512)
        auth_changes.theme = /*theme*/
        ctx2[9];
      if (dirty & /*localization*/
      1024)
        auth_changes.localization = /*localization*/
        ctx2[10];
      if (dirty & /*additionalData*/
      2048)
        auth_changes.additionalData = /*additionalData*/
        ctx2[11];
      if (dirty & /*$$scope*/
      8192) {
        auth_changes.$$scope = { dirty, ctx: ctx2 };
      }
      auth.$set(auth_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(auth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(auth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(auth, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SignUp", slots, ["default"]);
  let { supabaseClient } = $$props;
  let { socialLayout = "vertical" } = $$props;
  let { providers = [] } = $$props;
  let { providerScopes = void 0 } = $$props;
  let { queryParams = void 0 } = $$props;
  let { redirectTo = void 0 } = $$props;
  let { magicLink = false } = $$props;
  let { showLinks = false } = $$props;
  let { appearance = {} } = $$props;
  let { theme = "default" } = $$props;
  let { localization = {} } = $$props;
  let { additionalData = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<SignUp> was created without expected prop 'supabaseClient'");
    }
  });
  const writable_props = [
    "supabaseClient",
    "socialLayout",
    "providers",
    "providerScopes",
    "queryParams",
    "redirectTo",
    "magicLink",
    "showLinks",
    "appearance",
    "theme",
    "localization",
    "additionalData"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SignUp> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(1, socialLayout = $$props2.socialLayout);
    if ("providers" in $$props2)
      $$invalidate(2, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(3, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(4, queryParams = $$props2.queryParams);
    if ("redirectTo" in $$props2)
      $$invalidate(5, redirectTo = $$props2.redirectTo);
    if ("magicLink" in $$props2)
      $$invalidate(6, magicLink = $$props2.magicLink);
    if ("showLinks" in $$props2)
      $$invalidate(7, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(8, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(9, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(10, localization = $$props2.localization);
    if ("additionalData" in $$props2)
      $$invalidate(11, additionalData = $$props2.additionalData);
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Auth: Auth_default,
    supabaseClient,
    socialLayout,
    providers,
    providerScopes,
    queryParams,
    redirectTo,
    magicLink,
    showLinks,
    appearance,
    theme,
    localization,
    additionalData
  });
  $$self.$inject_state = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(1, socialLayout = $$props2.socialLayout);
    if ("providers" in $$props2)
      $$invalidate(2, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(3, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(4, queryParams = $$props2.queryParams);
    if ("redirectTo" in $$props2)
      $$invalidate(5, redirectTo = $$props2.redirectTo);
    if ("magicLink" in $$props2)
      $$invalidate(6, magicLink = $$props2.magicLink);
    if ("showLinks" in $$props2)
      $$invalidate(7, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(8, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(9, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(10, localization = $$props2.localization);
    if ("additionalData" in $$props2)
      $$invalidate(11, additionalData = $$props2.additionalData);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    supabaseClient,
    socialLayout,
    providers,
    providerScopes,
    queryParams,
    redirectTo,
    magicLink,
    showLinks,
    appearance,
    theme,
    localization,
    additionalData,
    slots,
    $$scope
  ];
}
var SignUp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {
      supabaseClient: 0,
      socialLayout: 1,
      providers: 2,
      providerScopes: 3,
      queryParams: 4,
      redirectTo: 5,
      magicLink: 6,
      showLinks: 7,
      appearance: 8,
      theme: 9,
      localization: 10,
      additionalData: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SignUp",
      options,
      id: create_fragment16.name
    });
  }
  get supabaseClient() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get socialLayout() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set socialLayout(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providers() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providers(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providerScopes() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providerScopes(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryParams() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryParams(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirectTo() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirectTo(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get magicLink() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set magicLink(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLinks() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLinks(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get localization() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set localization(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get additionalData() {
    throw new Error("<SignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set additionalData(value) {
    throw new Error("<SignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SignUp_default = SignUp;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/ui/SignIn.svelte
function create_fragment17(ctx) {
  let auth;
  let current;
  auth = new Auth_default({
    props: {
      view: "sign_in",
      onlyThirdPartyProviders: false,
      supabaseClient: (
        /*supabaseClient*/
        ctx[0]
      ),
      showLinks: (
        /*showLinks*/
        ctx[7]
      ),
      redirectTo: (
        /*redirectTo*/
        ctx[5]
      ),
      socialLayout: (
        /*socialLayout*/
        ctx[1]
      ),
      providers: (
        /*providers*/
        ctx[2]
      ),
      providerScopes: (
        /*providerScopes*/
        ctx[3]
      ),
      queryParams: (
        /*queryParams*/
        ctx[4]
      ),
      magicLink: (
        /*magicLink*/
        ctx[6]
      ),
      appearance: (
        /*appearance*/
        ctx[8]
      ),
      theme: (
        /*theme*/
        ctx[9]
      ),
      localization: (
        /*localization*/
        ctx[10]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(auth.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(auth.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(auth, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const auth_changes = {};
      if (dirty & /*supabaseClient*/
      1)
        auth_changes.supabaseClient = /*supabaseClient*/
        ctx2[0];
      if (dirty & /*showLinks*/
      128)
        auth_changes.showLinks = /*showLinks*/
        ctx2[7];
      if (dirty & /*redirectTo*/
      32)
        auth_changes.redirectTo = /*redirectTo*/
        ctx2[5];
      if (dirty & /*socialLayout*/
      2)
        auth_changes.socialLayout = /*socialLayout*/
        ctx2[1];
      if (dirty & /*providers*/
      4)
        auth_changes.providers = /*providers*/
        ctx2[2];
      if (dirty & /*providerScopes*/
      8)
        auth_changes.providerScopes = /*providerScopes*/
        ctx2[3];
      if (dirty & /*queryParams*/
      16)
        auth_changes.queryParams = /*queryParams*/
        ctx2[4];
      if (dirty & /*magicLink*/
      64)
        auth_changes.magicLink = /*magicLink*/
        ctx2[6];
      if (dirty & /*appearance*/
      256)
        auth_changes.appearance = /*appearance*/
        ctx2[8];
      if (dirty & /*theme*/
      512)
        auth_changes.theme = /*theme*/
        ctx2[9];
      if (dirty & /*localization*/
      1024)
        auth_changes.localization = /*localization*/
        ctx2[10];
      auth.$set(auth_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(auth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(auth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(auth, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SignIn", slots, []);
  let { supabaseClient } = $$props;
  let { socialLayout = "vertical" } = $$props;
  let { providers = [] } = $$props;
  let { providerScopes = void 0 } = $$props;
  let { queryParams = void 0 } = $$props;
  let { redirectTo = void 0 } = $$props;
  let { magicLink = false } = $$props;
  let { showLinks = false } = $$props;
  let { appearance = {} } = $$props;
  let { theme = "default" } = $$props;
  let { localization = {} } = $$props;
  $$self.$$.on_mount.push(function() {
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<SignIn> was created without expected prop 'supabaseClient'");
    }
  });
  const writable_props = [
    "supabaseClient",
    "socialLayout",
    "providers",
    "providerScopes",
    "queryParams",
    "redirectTo",
    "magicLink",
    "showLinks",
    "appearance",
    "theme",
    "localization"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SignIn> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(1, socialLayout = $$props2.socialLayout);
    if ("providers" in $$props2)
      $$invalidate(2, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(3, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(4, queryParams = $$props2.queryParams);
    if ("redirectTo" in $$props2)
      $$invalidate(5, redirectTo = $$props2.redirectTo);
    if ("magicLink" in $$props2)
      $$invalidate(6, magicLink = $$props2.magicLink);
    if ("showLinks" in $$props2)
      $$invalidate(7, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(8, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(9, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(10, localization = $$props2.localization);
  };
  $$self.$capture_state = () => ({
    Auth: Auth_default,
    supabaseClient,
    socialLayout,
    providers,
    providerScopes,
    queryParams,
    redirectTo,
    magicLink,
    showLinks,
    appearance,
    theme,
    localization
  });
  $$self.$inject_state = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(1, socialLayout = $$props2.socialLayout);
    if ("providers" in $$props2)
      $$invalidate(2, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(3, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(4, queryParams = $$props2.queryParams);
    if ("redirectTo" in $$props2)
      $$invalidate(5, redirectTo = $$props2.redirectTo);
    if ("magicLink" in $$props2)
      $$invalidate(6, magicLink = $$props2.magicLink);
    if ("showLinks" in $$props2)
      $$invalidate(7, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(8, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(9, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(10, localization = $$props2.localization);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    supabaseClient,
    socialLayout,
    providers,
    providerScopes,
    queryParams,
    redirectTo,
    magicLink,
    showLinks,
    appearance,
    theme,
    localization
  ];
}
var SignIn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {
      supabaseClient: 0,
      socialLayout: 1,
      providers: 2,
      providerScopes: 3,
      queryParams: 4,
      redirectTo: 5,
      magicLink: 6,
      showLinks: 7,
      appearance: 8,
      theme: 9,
      localization: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SignIn",
      options,
      id: create_fragment17.name
    });
  }
  get supabaseClient() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get socialLayout() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set socialLayout(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providers() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providers(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providerScopes() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providerScopes(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryParams() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryParams(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirectTo() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirectTo(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get magicLink() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set magicLink(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLinks() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLinks(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get localization() {
    throw new Error("<SignIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set localization(value) {
    throw new Error("<SignIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SignIn_default = SignIn;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/ui/MagicLink.svelte
function create_fragment18(ctx) {
  let auth;
  let current;
  auth = new Auth_default({
    props: {
      supabaseClient: (
        /*supabaseClient*/
        ctx[0]
      ),
      showLinks: false,
      magicLink: false,
      redirectTo: (
        /*redirectTo*/
        ctx[5]
      ),
      view: "magic_link",
      socialLayout: (
        /*socialLayout*/
        ctx[1]
      ),
      providers: (
        /*providers*/
        ctx[2]
      ),
      providerScopes: (
        /*providerScopes*/
        ctx[3]
      ),
      queryParams: (
        /*queryParams*/
        ctx[4]
      ),
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      theme: (
        /*theme*/
        ctx[7]
      ),
      localization: (
        /*localization*/
        ctx[8]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(auth.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(auth.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(auth, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const auth_changes = {};
      if (dirty & /*supabaseClient*/
      1)
        auth_changes.supabaseClient = /*supabaseClient*/
        ctx2[0];
      if (dirty & /*redirectTo*/
      32)
        auth_changes.redirectTo = /*redirectTo*/
        ctx2[5];
      if (dirty & /*socialLayout*/
      2)
        auth_changes.socialLayout = /*socialLayout*/
        ctx2[1];
      if (dirty & /*providers*/
      4)
        auth_changes.providers = /*providers*/
        ctx2[2];
      if (dirty & /*providerScopes*/
      8)
        auth_changes.providerScopes = /*providerScopes*/
        ctx2[3];
      if (dirty & /*queryParams*/
      16)
        auth_changes.queryParams = /*queryParams*/
        ctx2[4];
      if (dirty & /*appearance*/
      64)
        auth_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*theme*/
      128)
        auth_changes.theme = /*theme*/
        ctx2[7];
      if (dirty & /*localization*/
      256)
        auth_changes.localization = /*localization*/
        ctx2[8];
      auth.$set(auth_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(auth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(auth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(auth, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MagicLink", slots, []);
  let { supabaseClient } = $$props;
  let { socialLayout = "vertical" } = $$props;
  let { providers = [] } = $$props;
  let { providerScopes = void 0 } = $$props;
  let { queryParams = void 0 } = $$props;
  let { redirectTo = void 0 } = $$props;
  let { appearance = {} } = $$props;
  let { theme = "default" } = $$props;
  let { localization = {} } = $$props;
  $$self.$$.on_mount.push(function() {
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<MagicLink> was created without expected prop 'supabaseClient'");
    }
  });
  const writable_props = [
    "supabaseClient",
    "socialLayout",
    "providers",
    "providerScopes",
    "queryParams",
    "redirectTo",
    "appearance",
    "theme",
    "localization"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MagicLink> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(1, socialLayout = $$props2.socialLayout);
    if ("providers" in $$props2)
      $$invalidate(2, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(3, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(4, queryParams = $$props2.queryParams);
    if ("redirectTo" in $$props2)
      $$invalidate(5, redirectTo = $$props2.redirectTo);
    if ("appearance" in $$props2)
      $$invalidate(6, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(7, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(8, localization = $$props2.localization);
  };
  $$self.$capture_state = () => ({
    Auth: Auth_default,
    supabaseClient,
    socialLayout,
    providers,
    providerScopes,
    queryParams,
    redirectTo,
    appearance,
    theme,
    localization
  });
  $$self.$inject_state = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(1, socialLayout = $$props2.socialLayout);
    if ("providers" in $$props2)
      $$invalidate(2, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(3, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(4, queryParams = $$props2.queryParams);
    if ("redirectTo" in $$props2)
      $$invalidate(5, redirectTo = $$props2.redirectTo);
    if ("appearance" in $$props2)
      $$invalidate(6, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(7, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(8, localization = $$props2.localization);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    supabaseClient,
    socialLayout,
    providers,
    providerScopes,
    queryParams,
    redirectTo,
    appearance,
    theme,
    localization
  ];
}
var MagicLink2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      supabaseClient: 0,
      socialLayout: 1,
      providers: 2,
      providerScopes: 3,
      queryParams: 4,
      redirectTo: 5,
      appearance: 6,
      theme: 7,
      localization: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MagicLink",
      options,
      id: create_fragment18.name
    });
  }
  get supabaseClient() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get socialLayout() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set socialLayout(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providers() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providers(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providerScopes() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providerScopes(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryParams() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryParams(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirectTo() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirectTo(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get localization() {
    throw new Error("<MagicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set localization(value) {
    throw new Error("<MagicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MagicLink_default2 = MagicLink2;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/ui/SocialAuth.svelte
function create_fragment19(ctx) {
  let auth;
  let current;
  auth = new Auth_default({
    props: {
      view: "sign_in",
      showLinks: false,
      onlyThirdPartyProviders: true,
      supabaseClient: (
        /*supabaseClient*/
        ctx[0]
      ),
      redirectTo: (
        /*redirectTo*/
        ctx[5]
      ),
      socialLayout: (
        /*socialLayout*/
        ctx[1]
      ),
      providers: (
        /*providers*/
        ctx[2]
      ),
      providerScopes: (
        /*providerScopes*/
        ctx[3]
      ),
      queryParams: (
        /*queryParams*/
        ctx[4]
      ),
      appearance: (
        /*appearance*/
        ctx[6]
      ),
      theme: (
        /*theme*/
        ctx[7]
      ),
      localization: (
        /*localization*/
        ctx[8]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(auth.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(auth.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(auth, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const auth_changes = {};
      if (dirty & /*supabaseClient*/
      1)
        auth_changes.supabaseClient = /*supabaseClient*/
        ctx2[0];
      if (dirty & /*redirectTo*/
      32)
        auth_changes.redirectTo = /*redirectTo*/
        ctx2[5];
      if (dirty & /*socialLayout*/
      2)
        auth_changes.socialLayout = /*socialLayout*/
        ctx2[1];
      if (dirty & /*providers*/
      4)
        auth_changes.providers = /*providers*/
        ctx2[2];
      if (dirty & /*providerScopes*/
      8)
        auth_changes.providerScopes = /*providerScopes*/
        ctx2[3];
      if (dirty & /*queryParams*/
      16)
        auth_changes.queryParams = /*queryParams*/
        ctx2[4];
      if (dirty & /*appearance*/
      64)
        auth_changes.appearance = /*appearance*/
        ctx2[6];
      if (dirty & /*theme*/
      128)
        auth_changes.theme = /*theme*/
        ctx2[7];
      if (dirty & /*localization*/
      256)
        auth_changes.localization = /*localization*/
        ctx2[8];
      auth.$set(auth_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(auth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(auth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(auth, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SocialAuth", slots, []);
  let { supabaseClient } = $$props;
  let { socialLayout = "vertical" } = $$props;
  let { providers = [] } = $$props;
  let { providerScopes = void 0 } = $$props;
  let { queryParams = void 0 } = $$props;
  let { redirectTo = void 0 } = $$props;
  let { appearance = {} } = $$props;
  let { theme = "default" } = $$props;
  let { localization = {} } = $$props;
  $$self.$$.on_mount.push(function() {
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<SocialAuth> was created without expected prop 'supabaseClient'");
    }
  });
  const writable_props = [
    "supabaseClient",
    "socialLayout",
    "providers",
    "providerScopes",
    "queryParams",
    "redirectTo",
    "appearance",
    "theme",
    "localization"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SocialAuth> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(1, socialLayout = $$props2.socialLayout);
    if ("providers" in $$props2)
      $$invalidate(2, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(3, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(4, queryParams = $$props2.queryParams);
    if ("redirectTo" in $$props2)
      $$invalidate(5, redirectTo = $$props2.redirectTo);
    if ("appearance" in $$props2)
      $$invalidate(6, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(7, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(8, localization = $$props2.localization);
  };
  $$self.$capture_state = () => ({
    Auth: Auth_default,
    supabaseClient,
    socialLayout,
    providers,
    providerScopes,
    queryParams,
    redirectTo,
    appearance,
    theme,
    localization
  });
  $$self.$inject_state = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("socialLayout" in $$props2)
      $$invalidate(1, socialLayout = $$props2.socialLayout);
    if ("providers" in $$props2)
      $$invalidate(2, providers = $$props2.providers);
    if ("providerScopes" in $$props2)
      $$invalidate(3, providerScopes = $$props2.providerScopes);
    if ("queryParams" in $$props2)
      $$invalidate(4, queryParams = $$props2.queryParams);
    if ("redirectTo" in $$props2)
      $$invalidate(5, redirectTo = $$props2.redirectTo);
    if ("appearance" in $$props2)
      $$invalidate(6, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(7, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(8, localization = $$props2.localization);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    supabaseClient,
    socialLayout,
    providers,
    providerScopes,
    queryParams,
    redirectTo,
    appearance,
    theme,
    localization
  ];
}
var SocialAuth2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      supabaseClient: 0,
      socialLayout: 1,
      providers: 2,
      providerScopes: 3,
      queryParams: 4,
      redirectTo: 5,
      appearance: 6,
      theme: 7,
      localization: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SocialAuth",
      options,
      id: create_fragment19.name
    });
  }
  get supabaseClient() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get socialLayout() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set socialLayout(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providers() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providers(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get providerScopes() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set providerScopes(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryParams() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryParams(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirectTo() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirectTo(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get localization() {
    throw new Error("<SocialAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set localization(value) {
    throw new Error("<SocialAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SocialAuth_default2 = SocialAuth2;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/ui/ForgottenPassword.svelte
function create_fragment20(ctx) {
  let auth;
  let current;
  auth = new Auth_default({
    props: {
      view: "forgotten_password",
      showLinks: (
        /*showLinks*/
        ctx[2]
      ),
      supabaseClient: (
        /*supabaseClient*/
        ctx[0]
      ),
      redirectTo: (
        /*redirectTo*/
        ctx[1]
      ),
      appearance: (
        /*appearance*/
        ctx[3]
      ),
      theme: (
        /*theme*/
        ctx[4]
      ),
      localization: (
        /*localization*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(auth.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(auth.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(auth, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const auth_changes = {};
      if (dirty & /*showLinks*/
      4)
        auth_changes.showLinks = /*showLinks*/
        ctx2[2];
      if (dirty & /*supabaseClient*/
      1)
        auth_changes.supabaseClient = /*supabaseClient*/
        ctx2[0];
      if (dirty & /*redirectTo*/
      2)
        auth_changes.redirectTo = /*redirectTo*/
        ctx2[1];
      if (dirty & /*appearance*/
      8)
        auth_changes.appearance = /*appearance*/
        ctx2[3];
      if (dirty & /*theme*/
      16)
        auth_changes.theme = /*theme*/
        ctx2[4];
      if (dirty & /*localization*/
      32)
        auth_changes.localization = /*localization*/
        ctx2[5];
      auth.$set(auth_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(auth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(auth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(auth, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ForgottenPassword", slots, []);
  let { supabaseClient } = $$props;
  let { redirectTo = void 0 } = $$props;
  let { showLinks = false } = $$props;
  let { appearance = {} } = $$props;
  let { theme = "default" } = $$props;
  let { localization = {} } = $$props;
  $$self.$$.on_mount.push(function() {
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<ForgottenPassword> was created without expected prop 'supabaseClient'");
    }
  });
  const writable_props = [
    "supabaseClient",
    "redirectTo",
    "showLinks",
    "appearance",
    "theme",
    "localization"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ForgottenPassword> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("redirectTo" in $$props2)
      $$invalidate(1, redirectTo = $$props2.redirectTo);
    if ("showLinks" in $$props2)
      $$invalidate(2, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(3, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(4, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(5, localization = $$props2.localization);
  };
  $$self.$capture_state = () => ({
    Auth: Auth_default,
    supabaseClient,
    redirectTo,
    showLinks,
    appearance,
    theme,
    localization
  });
  $$self.$inject_state = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("redirectTo" in $$props2)
      $$invalidate(1, redirectTo = $$props2.redirectTo);
    if ("showLinks" in $$props2)
      $$invalidate(2, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(3, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(4, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(5, localization = $$props2.localization);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [supabaseClient, redirectTo, showLinks, appearance, theme, localization];
}
var ForgottenPassword2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {
      supabaseClient: 0,
      redirectTo: 1,
      showLinks: 2,
      appearance: 3,
      theme: 4,
      localization: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ForgottenPassword",
      options,
      id: create_fragment20.name
    });
  }
  get supabaseClient() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirectTo() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirectTo(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLinks() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLinks(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get localization() {
    throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set localization(value) {
    throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ForgottenPassword_default2 = ForgottenPassword2;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/ui/UpdatePassword.svelte
function create_fragment21(ctx) {
  let auth;
  let current;
  auth = new Auth_default({
    props: {
      view: "update_password",
      showLinks: (
        /*showLinks*/
        ctx[2]
      ),
      supabaseClient: (
        /*supabaseClient*/
        ctx[0]
      ),
      redirectTo: (
        /*redirectTo*/
        ctx[1]
      ),
      appearance: (
        /*appearance*/
        ctx[3]
      ),
      theme: (
        /*theme*/
        ctx[4]
      ),
      localization: (
        /*localization*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(auth.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(auth.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(auth, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const auth_changes = {};
      if (dirty & /*showLinks*/
      4)
        auth_changes.showLinks = /*showLinks*/
        ctx2[2];
      if (dirty & /*supabaseClient*/
      1)
        auth_changes.supabaseClient = /*supabaseClient*/
        ctx2[0];
      if (dirty & /*redirectTo*/
      2)
        auth_changes.redirectTo = /*redirectTo*/
        ctx2[1];
      if (dirty & /*appearance*/
      8)
        auth_changes.appearance = /*appearance*/
        ctx2[3];
      if (dirty & /*theme*/
      16)
        auth_changes.theme = /*theme*/
        ctx2[4];
      if (dirty & /*localization*/
      32)
        auth_changes.localization = /*localization*/
        ctx2[5];
      auth.$set(auth_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(auth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(auth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(auth, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UpdatePassword", slots, []);
  let { supabaseClient } = $$props;
  let { redirectTo = void 0 } = $$props;
  let { showLinks = false } = $$props;
  let { appearance = {} } = $$props;
  let { theme = "default" } = $$props;
  let { localization = {} } = $$props;
  $$self.$$.on_mount.push(function() {
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<UpdatePassword> was created without expected prop 'supabaseClient'");
    }
  });
  const writable_props = [
    "supabaseClient",
    "redirectTo",
    "showLinks",
    "appearance",
    "theme",
    "localization"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UpdatePassword> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("redirectTo" in $$props2)
      $$invalidate(1, redirectTo = $$props2.redirectTo);
    if ("showLinks" in $$props2)
      $$invalidate(2, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(3, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(4, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(5, localization = $$props2.localization);
  };
  $$self.$capture_state = () => ({
    Auth: Auth_default,
    supabaseClient,
    redirectTo,
    showLinks,
    appearance,
    theme,
    localization
  });
  $$self.$inject_state = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("redirectTo" in $$props2)
      $$invalidate(1, redirectTo = $$props2.redirectTo);
    if ("showLinks" in $$props2)
      $$invalidate(2, showLinks = $$props2.showLinks);
    if ("appearance" in $$props2)
      $$invalidate(3, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(4, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(5, localization = $$props2.localization);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [supabaseClient, redirectTo, showLinks, appearance, theme, localization];
}
var UpdatePassword2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      supabaseClient: 0,
      redirectTo: 1,
      showLinks: 2,
      appearance: 3,
      theme: 4,
      localization: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UpdatePassword",
      options,
      id: create_fragment21.name
    });
  }
  get supabaseClient() {
    throw new Error("<UpdatePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<UpdatePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirectTo() {
    throw new Error("<UpdatePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirectTo(value) {
    throw new Error("<UpdatePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLinks() {
    throw new Error("<UpdatePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLinks(value) {
    throw new Error("<UpdatePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<UpdatePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<UpdatePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<UpdatePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<UpdatePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get localization() {
    throw new Error("<UpdatePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set localization(value) {
    throw new Error("<UpdatePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UpdatePassword_default2 = UpdatePassword2;

// node_modules/@supabase/auth-ui-svelte/dist/Auth/ui/VerifyOtp.svelte
function create_fragment22(ctx) {
  let auth;
  let current;
  auth = new Auth_default({
    props: {
      supabaseClient: (
        /*supabaseClient*/
        ctx[0]
      ),
      showLinks: false,
      magicLink: false,
      view: "verify_otp",
      otpType: (
        /*otpType*/
        ctx[1]
      ),
      appearance: (
        /*appearance*/
        ctx[2]
      ),
      theme: (
        /*theme*/
        ctx[3]
      ),
      localization: (
        /*localization*/
        ctx[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(auth.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(auth.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(auth, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const auth_changes = {};
      if (dirty & /*supabaseClient*/
      1)
        auth_changes.supabaseClient = /*supabaseClient*/
        ctx2[0];
      if (dirty & /*otpType*/
      2)
        auth_changes.otpType = /*otpType*/
        ctx2[1];
      if (dirty & /*appearance*/
      4)
        auth_changes.appearance = /*appearance*/
        ctx2[2];
      if (dirty & /*theme*/
      8)
        auth_changes.theme = /*theme*/
        ctx2[3];
      if (dirty & /*localization*/
      16)
        auth_changes.localization = /*localization*/
        ctx2[4];
      auth.$set(auth_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(auth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(auth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(auth, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VerifyOtp", slots, []);
  let { supabaseClient } = $$props;
  let { otpType = "email" } = $$props;
  let { appearance = {} } = $$props;
  let { theme = "default" } = $$props;
  let { localization = {} } = $$props;
  $$self.$$.on_mount.push(function() {
    if (supabaseClient === void 0 && !("supabaseClient" in $$props || $$self.$$.bound[$$self.$$.props["supabaseClient"]])) {
      console.warn("<VerifyOtp> was created without expected prop 'supabaseClient'");
    }
  });
  const writable_props = ["supabaseClient", "otpType", "appearance", "theme", "localization"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VerifyOtp> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("otpType" in $$props2)
      $$invalidate(1, otpType = $$props2.otpType);
    if ("appearance" in $$props2)
      $$invalidate(2, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(3, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(4, localization = $$props2.localization);
  };
  $$self.$capture_state = () => ({
    Auth: Auth_default,
    supabaseClient,
    otpType,
    appearance,
    theme,
    localization
  });
  $$self.$inject_state = ($$props2) => {
    if ("supabaseClient" in $$props2)
      $$invalidate(0, supabaseClient = $$props2.supabaseClient);
    if ("otpType" in $$props2)
      $$invalidate(1, otpType = $$props2.otpType);
    if ("appearance" in $$props2)
      $$invalidate(2, appearance = $$props2.appearance);
    if ("theme" in $$props2)
      $$invalidate(3, theme = $$props2.theme);
    if ("localization" in $$props2)
      $$invalidate(4, localization = $$props2.localization);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [supabaseClient, otpType, appearance, theme, localization];
}
var VerifyOtp2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      supabaseClient: 0,
      otpType: 1,
      appearance: 2,
      theme: 3,
      localization: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VerifyOtp",
      options,
      id: create_fragment22.name
    });
  }
  get supabaseClient() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set supabaseClient(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get otpType() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set otpType(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appearance() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appearance(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get localization() {
    throw new Error("<VerifyOtp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set localization(value) {
    throw new Error("<VerifyOtp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VerifyOtp_default2 = VerifyOtp2;
export {
  Auth_default as Auth,
  ForgottenPassword_default2 as ForgottenPassword,
  MagicLink_default2 as MagicLink,
  SignIn_default as SignIn,
  SignUp_default as SignUp,
  SocialAuth_default2 as SocialAuth,
  UpdatePassword_default2 as UpdatePassword,
  VerifyOtp_default2 as VerifyOtp
};
//# sourceMappingURL=@supabase_auth-ui-svelte.js.map
